<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>源码阅读之underscore.js</title>
    <url>/source-read/javascript.html</url>
    <content><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function (global, factory) &#123;</span><br><span class="line">  typeof exports &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof module !&#x3D;&#x3D; &#39;undefined&#39; ? module.exports &#x3D; factory() :</span><br><span class="line">  typeof define &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; define.amd ? define(&#39;underscore&#39;, factory) :</span><br><span class="line">  (global &#x3D; typeof globalThis !&#x3D;&#x3D; &#39;undefined&#39; ? globalThis : global || self, (function () &#123;</span><br><span class="line">    var current &#x3D; global._;</span><br><span class="line">    var exports &#x3D; global._ &#x3D; factory();</span><br><span class="line">    exports.noConflict &#x3D; function () &#123; global._ &#x3D; current; return exports; &#125;;</span><br><span class="line">  &#125;()));</span><br><span class="line">&#125;(this, (function () &#123;</span><br><span class="line">  &#x2F;&#x2F;     Underscore.js 1.13.2</span><br><span class="line">  &#x2F;&#x2F;     https:&#x2F;&#x2F;underscorejs.org</span><br><span class="line">  &#x2F;&#x2F;     (c) 2009-2021 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters &amp; Editors</span><br><span class="line">  &#x2F;&#x2F;     Underscore may be freely distributed under the MIT license.</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Current version.</span><br><span class="line">  var VERSION &#x3D; &#39;1.13.2&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Establish the root object, &#96;window&#96; (&#96;self&#96;) in the browser, &#96;global&#96;</span><br><span class="line">  &#x2F;&#x2F; on the server, or &#96;this&#96; in some virtual machines. We use &#96;self&#96;</span><br><span class="line">  &#x2F;&#x2F; instead of &#96;window&#96; for &#96;WebWorker&#96; support.</span><br><span class="line">  var root &#x3D; typeof self &#x3D;&#x3D; &#39;object&#39; &amp;&amp; self.self &#x3D;&#x3D;&#x3D; self &amp;&amp; self ||</span><br><span class="line">            typeof global &#x3D;&#x3D; &#39;object&#39; &amp;&amp; global.global &#x3D;&#x3D;&#x3D; global &amp;&amp; global ||</span><br><span class="line">            Function(&#39;return this&#39;)() ||</span><br><span class="line">            &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Save bytes in the minified (but not gzipped) version:</span><br><span class="line">  var ArrayProto &#x3D; Array.prototype, ObjProto &#x3D; Object.prototype;</span><br><span class="line">  var SymbolProto &#x3D; typeof Symbol !&#x3D;&#x3D; &#39;undefined&#39; ? Symbol.prototype : null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Create quick reference variables for speed access to core prototypes.</span><br><span class="line">  var push &#x3D; ArrayProto.push,</span><br><span class="line">      slice &#x3D; ArrayProto.slice,</span><br><span class="line">      toString &#x3D; ObjProto.toString,</span><br><span class="line">      hasOwnProperty &#x3D; ObjProto.hasOwnProperty;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Modern feature detection.</span><br><span class="line">  var supportsArrayBuffer &#x3D; typeof ArrayBuffer !&#x3D;&#x3D; &#39;undefined&#39;,</span><br><span class="line">      supportsDataView &#x3D; typeof DataView !&#x3D;&#x3D; &#39;undefined&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; All **ECMAScript 5+** native function implementations that we hope to use</span><br><span class="line">  &#x2F;&#x2F; are declared here.</span><br><span class="line">  var nativeIsArray &#x3D; Array.isArray,</span><br><span class="line">      nativeKeys &#x3D; Object.keys,</span><br><span class="line">      nativeCreate &#x3D; Object.create,</span><br><span class="line">      nativeIsView &#x3D; supportsArrayBuffer &amp;&amp; ArrayBuffer.isView;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Create references to these builtin functions because we override them.</span><br><span class="line">  var _isNaN &#x3D; isNaN,</span><br><span class="line">      _isFinite &#x3D; isFinite;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Keys in IE &lt; 9 that won&#39;t be iterated by &#96;for key in ...&#96; and thus missed.</span><br><span class="line">  var hasEnumBug &#x3D; !&#123;toString: null&#125;.propertyIsEnumerable(&#39;toString&#39;);</span><br><span class="line">  var nonEnumerableProps &#x3D; [&#39;valueOf&#39;, &#39;isPrototypeOf&#39;, &#39;toString&#39;,</span><br><span class="line">    &#39;propertyIsEnumerable&#39;, &#39;hasOwnProperty&#39;, &#39;toLocaleString&#39;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The largest integer that can be represented exactly.</span><br><span class="line">  var MAX_ARRAY_INDEX &#x3D; Math.pow(2, 53) - 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Some functions take a variable number of arguments, or a few expected</span><br><span class="line">  &#x2F;&#x2F; arguments at the beginning and then a variable number of values to operate</span><br><span class="line">  &#x2F;&#x2F; on. This helper accumulates all remaining arguments past the function’s</span><br><span class="line">  &#x2F;&#x2F; argument length (or an explicit &#96;startIndex&#96;), into an array that becomes</span><br><span class="line">  &#x2F;&#x2F; the last argument. Similar to ES6’s &quot;rest parameter&quot;.</span><br><span class="line">  function restArguments(func, startIndex) &#123;</span><br><span class="line">    startIndex &#x3D; startIndex &#x3D;&#x3D; null ? func.length - 1 : +startIndex;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      var length &#x3D; Math.max(arguments.length - startIndex, 0),</span><br><span class="line">          rest &#x3D; Array(length),</span><br><span class="line">          index &#x3D; 0;</span><br><span class="line">      for (; index &lt; length; index++) &#123;</span><br><span class="line">        rest[index] &#x3D; arguments[index + startIndex];</span><br><span class="line">      &#125;</span><br><span class="line">      switch (startIndex) &#123;</span><br><span class="line">        case 0: return func.call(this, rest);</span><br><span class="line">        case 1: return func.call(this, arguments[0], rest);</span><br><span class="line">        case 2: return func.call(this, arguments[0], arguments[1], rest);</span><br><span class="line">      &#125;</span><br><span class="line">      var args &#x3D; Array(startIndex + 1);</span><br><span class="line">      for (index &#x3D; 0; index &lt; startIndex; index++) &#123;</span><br><span class="line">        args[index] &#x3D; arguments[index];</span><br><span class="line">      &#125;</span><br><span class="line">      args[startIndex] &#x3D; rest;</span><br><span class="line">      return func.apply(this, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given variable an object?</span><br><span class="line">  function isObject(obj) &#123;</span><br><span class="line">    var type &#x3D; typeof obj;</span><br><span class="line">    return type &#x3D;&#x3D;&#x3D; &#39;function&#39; || type &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; !!obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given value equal to null?</span><br><span class="line">  function isNull(obj) &#123;</span><br><span class="line">    return obj &#x3D;&#x3D;&#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given variable undefined?</span><br><span class="line">  function isUndefined(obj) &#123;</span><br><span class="line">    return obj &#x3D;&#x3D;&#x3D; void 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given value a boolean?</span><br><span class="line">  function isBoolean(obj) &#123;</span><br><span class="line">    return obj &#x3D;&#x3D;&#x3D; true || obj &#x3D;&#x3D;&#x3D; false || toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object Boolean]&#39;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given value a DOM element?</span><br><span class="line">  function isElement(obj) &#123;</span><br><span class="line">    return !!(obj &amp;&amp; obj.nodeType &#x3D;&#x3D;&#x3D; 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function for creating a &#96;toString&#96;-based type tester.</span><br><span class="line">  function tagTester(name) &#123;</span><br><span class="line">    var tag &#x3D; &#39;[object &#39; + name + &#39;]&#39;;</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      return toString.call(obj) &#x3D;&#x3D;&#x3D; tag;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var isString &#x3D; tagTester(&#39;String&#39;);</span><br><span class="line"></span><br><span class="line">  var isNumber &#x3D; tagTester(&#39;Number&#39;);</span><br><span class="line"></span><br><span class="line">  var isDate &#x3D; tagTester(&#39;Date&#39;);</span><br><span class="line"></span><br><span class="line">  var isRegExp &#x3D; tagTester(&#39;RegExp&#39;);</span><br><span class="line"></span><br><span class="line">  var isError &#x3D; tagTester(&#39;Error&#39;);</span><br><span class="line"></span><br><span class="line">  var isSymbol &#x3D; tagTester(&#39;Symbol&#39;);</span><br><span class="line"></span><br><span class="line">  var isArrayBuffer &#x3D; tagTester(&#39;ArrayBuffer&#39;);</span><br><span class="line"></span><br><span class="line">  var isFunction &#x3D; tagTester(&#39;Function&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Optimize &#96;isFunction&#96; if appropriate. Work around some &#96;typeof&#96; bugs in old</span><br><span class="line">  &#x2F;&#x2F; v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).</span><br><span class="line">  var nodelist &#x3D; root.document &amp;&amp; root.document.childNodes;</span><br><span class="line">  if (typeof &#x2F;.&#x2F; !&#x3D; &#39;function&#39; &amp;&amp; typeof Int8Array !&#x3D; &#39;object&#39; &amp;&amp; typeof nodelist !&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    isFunction &#x3D; function(obj) &#123;</span><br><span class="line">      return typeof obj &#x3D;&#x3D; &#39;function&#39; || false;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var isFunction$1 &#x3D; isFunction;</span><br><span class="line"></span><br><span class="line">  var hasObjectTag &#x3D; tagTester(&#39;Object&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; In IE 10 - Edge 13, &#96;DataView&#96; has string tag &#96;&#39;[object Object]&#39;&#96;.</span><br><span class="line">  &#x2F;&#x2F; In IE 11, the most common among them, this problem also applies to</span><br><span class="line">  &#x2F;&#x2F; &#96;Map&#96;, &#96;WeakMap&#96; and &#96;Set&#96;.</span><br><span class="line">  var hasStringTagBug &#x3D; (</span><br><span class="line">        supportsDataView &amp;&amp; hasObjectTag(new DataView(new ArrayBuffer(8)))</span><br><span class="line">      ),</span><br><span class="line">      isIE11 &#x3D; (typeof Map !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; hasObjectTag(new Map));</span><br><span class="line"></span><br><span class="line">  var isDataView &#x3D; tagTester(&#39;DataView&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; In IE 10 - Edge 13, we need a different heuristic</span><br><span class="line">  &#x2F;&#x2F; to determine whether an object is a &#96;DataView&#96;.</span><br><span class="line">  function ie10IsDataView(obj) &#123;</span><br><span class="line">    return obj !&#x3D; null &amp;&amp; isFunction$1(obj.getInt8) &amp;&amp; isArrayBuffer(obj.buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var isDataView$1 &#x3D; (hasStringTagBug ? ie10IsDataView : isDataView);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given value an array?</span><br><span class="line">  &#x2F;&#x2F; Delegates to ECMA5&#39;s native &#96;Array.isArray&#96;.</span><br><span class="line">  var isArray &#x3D; nativeIsArray || tagTester(&#39;Array&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function to check whether &#96;key&#96; is an own property name of &#96;obj&#96;.</span><br><span class="line">  function has$1(obj, key) &#123;</span><br><span class="line">    return obj !&#x3D; null &amp;&amp; hasOwnProperty.call(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var isArguments &#x3D; tagTester(&#39;Arguments&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Define a fallback version of the method in browsers (ahem, IE &lt; 9), where</span><br><span class="line">  &#x2F;&#x2F; there isn&#39;t any inspectable &quot;Arguments&quot; type.</span><br><span class="line">  (function() &#123;</span><br><span class="line">    if (!isArguments(arguments)) &#123;</span><br><span class="line">      isArguments &#x3D; function(obj) &#123;</span><br><span class="line">        return has$1(obj, &#39;callee&#39;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  var isArguments$1 &#x3D; isArguments;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given object a finite number?</span><br><span class="line">  function isFinite$1(obj) &#123;</span><br><span class="line">    return !isSymbol(obj) &amp;&amp; _isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is the given value &#96;NaN&#96;?</span><br><span class="line">  function isNaN$1(obj) &#123;</span><br><span class="line">    return isNumber(obj) &amp;&amp; _isNaN(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Predicate-generating function. Often useful outside of Underscore.</span><br><span class="line">  function constant(value) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      return value;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Common internal logic for &#96;isArrayLike&#96; and &#96;isBufferLike&#96;.</span><br><span class="line">  function createSizePropertyCheck(getSizeProperty) &#123;</span><br><span class="line">    return function(collection) &#123;</span><br><span class="line">      var sizeProperty &#x3D; getSizeProperty(collection);</span><br><span class="line">      return typeof sizeProperty &#x3D;&#x3D; &#39;number&#39; &amp;&amp; sizeProperty &gt;&#x3D; 0 &amp;&amp; sizeProperty &lt;&#x3D; MAX_ARRAY_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to generate a function to obtain property &#96;key&#96; from &#96;obj&#96;.</span><br><span class="line">  function shallowProperty(key) &#123;</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      return obj &#x3D;&#x3D; null ? void 0 : obj[key];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to obtain the &#96;byteLength&#96; property of an object.</span><br><span class="line">  var getByteLength &#x3D; shallowProperty(&#39;byteLength&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to determine whether we should spend extensive checks against</span><br><span class="line">  &#x2F;&#x2F; &#96;ArrayBuffer&#96; et al.</span><br><span class="line">  var isBufferLike &#x3D; createSizePropertyCheck(getByteLength);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given value a typed array?</span><br><span class="line">  var typedArrayPattern &#x3D; &#x2F;\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]&#x2F;;</span><br><span class="line">  function isTypedArray(obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; &#96;ArrayBuffer.isView&#96; is the most future-proof, so use it when available.</span><br><span class="line">    &#x2F;&#x2F; Otherwise, fall back on the above regular expression.</span><br><span class="line">    return nativeIsView ? (nativeIsView(obj) &amp;&amp; !isDataView$1(obj)) :</span><br><span class="line">                  isBufferLike(obj) &amp;&amp; typedArrayPattern.test(toString.call(obj));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var isTypedArray$1 &#x3D; supportsArrayBuffer ? isTypedArray : constant(false);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to obtain the &#96;length&#96; property of an object.</span><br><span class="line">  var getLength &#x3D; shallowProperty(&#39;length&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to create a simple lookup structure.</span><br><span class="line">  &#x2F;&#x2F; &#96;collectNonEnumProps&#96; used to depend on &#96;_.contains&#96;, but this led to</span><br><span class="line">  &#x2F;&#x2F; circular imports. &#96;emulatedSet&#96; is a one-off solution that only works for</span><br><span class="line">  &#x2F;&#x2F; arrays of strings.</span><br><span class="line">  function emulatedSet(keys) &#123;</span><br><span class="line">    var hash &#x3D; &#123;&#125;;</span><br><span class="line">    for (var l &#x3D; keys.length, i &#x3D; 0; i &lt; l; ++i) hash[keys[i]] &#x3D; true;</span><br><span class="line">    return &#123;</span><br><span class="line">      contains: function(key) &#123; return hash[key] &#x3D;&#x3D;&#x3D; true; &#125;,</span><br><span class="line">      push: function(key) &#123;</span><br><span class="line">        hash[key] &#x3D; true;</span><br><span class="line">        return keys.push(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper. Checks &#96;keys&#96; for the presence of keys in IE &lt; 9 that won&#39;t</span><br><span class="line">  &#x2F;&#x2F; be iterated by &#96;for key in ...&#96; and thus missed. Extends &#96;keys&#96; in place if</span><br><span class="line">  &#x2F;&#x2F; needed.</span><br><span class="line">  function collectNonEnumProps(obj, keys) &#123;</span><br><span class="line">    keys &#x3D; emulatedSet(keys);</span><br><span class="line">    var nonEnumIdx &#x3D; nonEnumerableProps.length;</span><br><span class="line">    var constructor &#x3D; obj.constructor;</span><br><span class="line">    var proto &#x3D; isFunction$1(constructor) &amp;&amp; constructor.prototype || ObjProto;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor is a special case.</span><br><span class="line">    var prop &#x3D; &#39;constructor&#39;;</span><br><span class="line">    if (has$1(obj, prop) &amp;&amp; !keys.contains(prop)) keys.push(prop);</span><br><span class="line"></span><br><span class="line">    while (nonEnumIdx--) &#123;</span><br><span class="line">      prop &#x3D; nonEnumerableProps[nonEnumIdx];</span><br><span class="line">      if (prop in obj &amp;&amp; obj[prop] !&#x3D;&#x3D; proto[prop] &amp;&amp; !keys.contains(prop)) &#123;</span><br><span class="line">        keys.push(prop);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Retrieve the names of an object&#39;s own properties.</span><br><span class="line">  &#x2F;&#x2F; Delegates to **ECMAScript 5**&#39;s native &#96;Object.keys&#96;.</span><br><span class="line">  function keys(obj) &#123;</span><br><span class="line">    if (!isObject(obj)) return [];</span><br><span class="line">    if (nativeKeys) return nativeKeys(obj);</span><br><span class="line">    var keys &#x3D; [];</span><br><span class="line">    for (var key in obj) if (has$1(obj, key)) keys.push(key);</span><br><span class="line">    &#x2F;&#x2F; Ahem, IE &lt; 9.</span><br><span class="line">    if (hasEnumBug) collectNonEnumProps(obj, keys);</span><br><span class="line">    return keys;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Is a given array, string, or object empty?</span><br><span class="line">  &#x2F;&#x2F; An &quot;empty&quot; object has no enumerable own-properties.</span><br><span class="line">  function isEmpty(obj) &#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) return true;</span><br><span class="line">    &#x2F;&#x2F; Skip the more expensive &#96;toString&#96;-based type checks if &#96;obj&#96; has no</span><br><span class="line">    &#x2F;&#x2F; &#96;.length&#96;.</span><br><span class="line">    var length &#x3D; getLength(obj);</span><br><span class="line">    if (typeof length &#x3D;&#x3D; &#39;number&#39; &amp;&amp; (</span><br><span class="line">      isArray(obj) || isString(obj) || isArguments$1(obj)</span><br><span class="line">    )) return length &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">    return getLength(keys(obj)) &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns whether an object has a given set of &#96;key:value&#96; pairs.</span><br><span class="line">  function isMatch(object, attrs) &#123;</span><br><span class="line">    var _keys &#x3D; keys(attrs), length &#x3D; _keys.length;</span><br><span class="line">    if (object &#x3D;&#x3D; null) return !length;</span><br><span class="line">    var obj &#x3D; Object(object);</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      var key &#x3D; _keys[i];</span><br><span class="line">      if (attrs[key] !&#x3D;&#x3D; obj[key] || !(key in obj)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If Underscore is called as a function, it returns a wrapped object that can</span><br><span class="line">  &#x2F;&#x2F; be used OO-style. This wrapper holds altered versions of all functions added</span><br><span class="line">  &#x2F;&#x2F; through &#96;_.mixin&#96;. Wrapped objects may be chained.</span><br><span class="line">  function _$1(obj) &#123;</span><br><span class="line">    if (obj instanceof _$1) return obj;</span><br><span class="line">    if (!(this instanceof _$1)) return new _$1(obj);</span><br><span class="line">    this._wrapped &#x3D; obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _$1.VERSION &#x3D; VERSION;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Extracts the result from a wrapped and chained object.</span><br><span class="line">  _$1.prototype.value &#x3D; function() &#123;</span><br><span class="line">    return this._wrapped;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Provide unwrapping proxies for some methods used in engine operations</span><br><span class="line">  &#x2F;&#x2F; such as arithmetic and JSON stringification.</span><br><span class="line">  _$1.prototype.valueOf &#x3D; _$1.prototype.toJSON &#x3D; _$1.prototype.value;</span><br><span class="line"></span><br><span class="line">  _$1.prototype.toString &#x3D; function() &#123;</span><br><span class="line">    return String(this._wrapped);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function to wrap or shallow-copy an ArrayBuffer,</span><br><span class="line">  &#x2F;&#x2F; typed array or DataView to a new view, reusing the buffer.</span><br><span class="line">  function toBufferView(bufferSource) &#123;</span><br><span class="line">    return new Uint8Array(</span><br><span class="line">      bufferSource.buffer || bufferSource,</span><br><span class="line">      bufferSource.byteOffset || 0,</span><br><span class="line">      getByteLength(bufferSource)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; We use this string twice, so give it a name for minification.</span><br><span class="line">  var tagDataView &#x3D; &#39;[object DataView]&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal recursive comparison function for &#96;_.isEqual&#96;.</span><br><span class="line">  function eq(a, b, aStack, bStack) &#123;</span><br><span class="line">    &#x2F;&#x2F; Identical objects are equal. &#96;0 &#x3D;&#x3D;&#x3D; -0&#96;, but they aren&#39;t identical.</span><br><span class="line">    &#x2F;&#x2F; See the [Harmony &#96;egal&#96; proposal](https:&#x2F;&#x2F;wiki.ecmascript.org&#x2F;doku.php?id&#x3D;harmony:egal).</span><br><span class="line">    if (a &#x3D;&#x3D;&#x3D; b) return a !&#x3D;&#x3D; 0 || 1 &#x2F; a &#x3D;&#x3D;&#x3D; 1 &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F; &#96;null&#96; or &#96;undefined&#96; only equal to itself (strict comparison).</span><br><span class="line">    if (a &#x3D;&#x3D; null || b &#x3D;&#x3D; null) return false;</span><br><span class="line">    &#x2F;&#x2F; &#96;NaN&#96;s are equivalent, but non-reflexive.</span><br><span class="line">    if (a !&#x3D;&#x3D; a) return b !&#x3D;&#x3D; b;</span><br><span class="line">    &#x2F;&#x2F; Exhaust primitive checks</span><br><span class="line">    var type &#x3D; typeof a;</span><br><span class="line">    if (type !&#x3D;&#x3D; &#39;function&#39; &amp;&amp; type !&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof b !&#x3D; &#39;object&#39;) return false;</span><br><span class="line">    return deepEq(a, b, aStack, bStack);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal recursive comparison function for &#96;_.isEqual&#96;.</span><br><span class="line">  function deepEq(a, b, aStack, bStack) &#123;</span><br><span class="line">    &#x2F;&#x2F; Unwrap any wrapped objects.</span><br><span class="line">    if (a instanceof _$1) a &#x3D; a._wrapped;</span><br><span class="line">    if (b instanceof _$1) b &#x3D; b._wrapped;</span><br><span class="line">    &#x2F;&#x2F; Compare &#96;[[Class]]&#96; names.</span><br><span class="line">    var className &#x3D; toString.call(a);</span><br><span class="line">    if (className !&#x3D;&#x3D; toString.call(b)) return false;</span><br><span class="line">    &#x2F;&#x2F; Work around a bug in IE 10 - Edge 13.</span><br><span class="line">    if (hasStringTagBug &amp;&amp; className &#x3D;&#x3D; &#39;[object Object]&#39; &amp;&amp; isDataView$1(a)) &#123;</span><br><span class="line">      if (!isDataView$1(b)) return false;</span><br><span class="line">      className &#x3D; tagDataView;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (className) &#123;</span><br><span class="line">      &#x2F;&#x2F; These types are compared by value.</span><br><span class="line">      case &#39;[object RegExp]&#39;:</span><br><span class="line">        &#x2F;&#x2F; RegExps are coerced to strings for comparison (Note: &#39;&#39; + &#x2F;a&#x2F;i &#x3D;&#x3D;&#x3D; &#39;&#x2F;a&#x2F;i&#39;)</span><br><span class="line">      case &#39;[object String]&#39;:</span><br><span class="line">        &#x2F;&#x2F; Primitives and their corresponding object wrappers are equivalent; thus, &#96;&quot;5&quot;&#96; is</span><br><span class="line">        &#x2F;&#x2F; equivalent to &#96;new String(&quot;5&quot;)&#96;.</span><br><span class="line">        return &#39;&#39; + a &#x3D;&#x3D;&#x3D; &#39;&#39; + b;</span><br><span class="line">      case &#39;[object Number]&#39;:</span><br><span class="line">        &#x2F;&#x2F; &#96;NaN&#96;s are equivalent, but non-reflexive.</span><br><span class="line">        &#x2F;&#x2F; Object(NaN) is equivalent to NaN.</span><br><span class="line">        if (+a !&#x3D;&#x3D; +a) return +b !&#x3D;&#x3D; +b;</span><br><span class="line">        &#x2F;&#x2F; An &#96;egal&#96; comparison is performed for other numeric values.</span><br><span class="line">        return +a &#x3D;&#x3D;&#x3D; 0 ? 1 &#x2F; +a &#x3D;&#x3D;&#x3D; 1 &#x2F; b : +a &#x3D;&#x3D;&#x3D; +b;</span><br><span class="line">      case &#39;[object Date]&#39;:</span><br><span class="line">      case &#39;[object Boolean]&#39;:</span><br><span class="line">        &#x2F;&#x2F; Coerce dates and booleans to numeric primitive values. Dates are compared by their</span><br><span class="line">        &#x2F;&#x2F; millisecond representations. Note that invalid dates with millisecond representations</span><br><span class="line">        &#x2F;&#x2F; of &#96;NaN&#96; are not equivalent.</span><br><span class="line">        return +a &#x3D;&#x3D;&#x3D; +b;</span><br><span class="line">      case &#39;[object Symbol]&#39;:</span><br><span class="line">        return SymbolProto.valueOf.call(a) &#x3D;&#x3D;&#x3D; SymbolProto.valueOf.call(b);</span><br><span class="line">      case &#39;[object ArrayBuffer]&#39;:</span><br><span class="line">      case tagDataView:</span><br><span class="line">        &#x2F;&#x2F; Coerce to typed array so we can fall through.</span><br><span class="line">        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var areArrays &#x3D; className &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39;;</span><br><span class="line">    if (!areArrays &amp;&amp; isTypedArray$1(a)) &#123;</span><br><span class="line">        var byteLength &#x3D; getByteLength(a);</span><br><span class="line">        if (byteLength !&#x3D;&#x3D; getByteLength(b)) return false;</span><br><span class="line">        if (a.buffer &#x3D;&#x3D;&#x3D; b.buffer &amp;&amp; a.byteOffset &#x3D;&#x3D;&#x3D; b.byteOffset) return true;</span><br><span class="line">        areArrays &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!areArrays) &#123;</span><br><span class="line">      if (typeof a !&#x3D; &#39;object&#39; || typeof b !&#x3D; &#39;object&#39;) return false;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Objects with different constructors are not equivalent, but &#96;Object&#96;s or &#96;Array&#96;s</span><br><span class="line">      &#x2F;&#x2F; from different frames are.</span><br><span class="line">      var aCtor &#x3D; a.constructor, bCtor &#x3D; b.constructor;</span><br><span class="line">      if (aCtor !&#x3D;&#x3D; bCtor &amp;&amp; !(isFunction$1(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp;</span><br><span class="line">                               isFunction$1(bCtor) &amp;&amp; bCtor instanceof bCtor)</span><br><span class="line">                          &amp;&amp; (&#39;constructor&#39; in a &amp;&amp; &#39;constructor&#39; in b)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Assume equality for cyclic structures. The algorithm for detecting cyclic</span><br><span class="line">    &#x2F;&#x2F; structures is adapted from ES 5.1 section 15.12.3, abstract operation &#96;JO&#96;.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Initializing stack of traversed objects.</span><br><span class="line">    &#x2F;&#x2F; It&#39;s done here since we only need them for objects and arrays comparison.</span><br><span class="line">    aStack &#x3D; aStack || [];</span><br><span class="line">    bStack &#x3D; bStack || [];</span><br><span class="line">    var length &#x3D; aStack.length;</span><br><span class="line">    while (length--) &#123;</span><br><span class="line">      &#x2F;&#x2F; Linear search. Performance is inversely proportional to the number of</span><br><span class="line">      &#x2F;&#x2F; unique nested structures.</span><br><span class="line">      if (aStack[length] &#x3D;&#x3D;&#x3D; a) return bStack[length] &#x3D;&#x3D;&#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Add the first object to the stack of traversed objects.</span><br><span class="line">    aStack.push(a);</span><br><span class="line">    bStack.push(b);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Recursively compare objects and arrays.</span><br><span class="line">    if (areArrays) &#123;</span><br><span class="line">      &#x2F;&#x2F; Compare array lengths to determine if a deep comparison is necessary.</span><br><span class="line">      length &#x3D; a.length;</span><br><span class="line">      if (length !&#x3D;&#x3D; b.length) return false;</span><br><span class="line">      &#x2F;&#x2F; Deep compare the contents, ignoring non-numeric properties.</span><br><span class="line">      while (length--) &#123;</span><br><span class="line">        if (!eq(a[length], b[length], aStack, bStack)) return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; Deep compare objects.</span><br><span class="line">      var _keys &#x3D; keys(a), key;</span><br><span class="line">      length &#x3D; _keys.length;</span><br><span class="line">      &#x2F;&#x2F; Ensure that both objects contain the same number of properties before comparing deep equality.</span><br><span class="line">      if (keys(b).length !&#x3D;&#x3D; length) return false;</span><br><span class="line">      while (length--) &#123;</span><br><span class="line">        &#x2F;&#x2F; Deep compare each member</span><br><span class="line">        key &#x3D; _keys[length];</span><br><span class="line">        if (!(has$1(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Remove the first object from the stack of traversed objects.</span><br><span class="line">    aStack.pop();</span><br><span class="line">    bStack.pop();</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Perform a deep comparison to check if two objects are equal.</span><br><span class="line">  function isEqual(a, b) &#123;</span><br><span class="line">    return eq(a, b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Retrieve all the enumerable property names of an object.</span><br><span class="line">  function allKeys(obj) &#123;</span><br><span class="line">    if (!isObject(obj)) return [];</span><br><span class="line">    var keys &#x3D; [];</span><br><span class="line">    for (var key in obj) keys.push(key);</span><br><span class="line">    &#x2F;&#x2F; Ahem, IE &lt; 9.</span><br><span class="line">    if (hasEnumBug) collectNonEnumProps(obj, keys);</span><br><span class="line">    return keys;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Since the regular &#96;Object.prototype.toString&#96; type tests don&#39;t work for</span><br><span class="line">  &#x2F;&#x2F; some types in IE 11, we use a fingerprinting heuristic instead, based</span><br><span class="line">  &#x2F;&#x2F; on the methods. It&#39;s not great, but it&#39;s the best we got.</span><br><span class="line">  &#x2F;&#x2F; The fingerprint method lists are defined below.</span><br><span class="line">  function ie11fingerprint(methods) &#123;</span><br><span class="line">    var length &#x3D; getLength(methods);</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      if (obj &#x3D;&#x3D; null) return false;</span><br><span class="line">      &#x2F;&#x2F; &#96;Map&#96;, &#96;WeakMap&#96; and &#96;Set&#96; have no enumerable keys.</span><br><span class="line">      var keys &#x3D; allKeys(obj);</span><br><span class="line">      if (getLength(keys)) return false;</span><br><span class="line">      for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        if (!isFunction$1(obj[methods[i]])) return false;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; If we are testing against &#96;WeakMap&#96;, we need to ensure that</span><br><span class="line">      &#x2F;&#x2F; &#96;obj&#96; doesn&#39;t have a &#96;forEach&#96; method in order to distinguish</span><br><span class="line">      &#x2F;&#x2F; it from a regular &#96;Map&#96;.</span><br><span class="line">      return methods !&#x3D;&#x3D; weakMapMethods || !isFunction$1(obj[forEachName]);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; In the interest of compact minification, we write</span><br><span class="line">  &#x2F;&#x2F; each string in the fingerprints only once.</span><br><span class="line">  var forEachName &#x3D; &#39;forEach&#39;,</span><br><span class="line">      hasName &#x3D; &#39;has&#39;,</span><br><span class="line">      commonInit &#x3D; [&#39;clear&#39;, &#39;delete&#39;],</span><br><span class="line">      mapTail &#x3D; [&#39;get&#39;, hasName, &#39;set&#39;];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &#96;Map&#96;, &#96;WeakMap&#96; and &#96;Set&#96; each have slightly different</span><br><span class="line">  &#x2F;&#x2F; combinations of the above sublists.</span><br><span class="line">  var mapMethods &#x3D; commonInit.concat(forEachName, mapTail),</span><br><span class="line">      weakMapMethods &#x3D; commonInit.concat(mapTail),</span><br><span class="line">      setMethods &#x3D; [&#39;add&#39;].concat(commonInit, forEachName, hasName);</span><br><span class="line"></span><br><span class="line">  var isMap &#x3D; isIE11 ? ie11fingerprint(mapMethods) : tagTester(&#39;Map&#39;);</span><br><span class="line"></span><br><span class="line">  var isWeakMap &#x3D; isIE11 ? ie11fingerprint(weakMapMethods) : tagTester(&#39;WeakMap&#39;);</span><br><span class="line"></span><br><span class="line">  var isSet &#x3D; isIE11 ? ie11fingerprint(setMethods) : tagTester(&#39;Set&#39;);</span><br><span class="line"></span><br><span class="line">  var isWeakSet &#x3D; tagTester(&#39;WeakSet&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Retrieve the values of an object&#39;s properties.</span><br><span class="line">  function values(obj) &#123;</span><br><span class="line">    var _keys &#x3D; keys(obj);</span><br><span class="line">    var length &#x3D; _keys.length;</span><br><span class="line">    var values &#x3D; Array(length);</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      values[i] &#x3D; obj[_keys[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return values;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Convert an object into a list of &#96;[key, value]&#96; pairs.</span><br><span class="line">  &#x2F;&#x2F; The opposite of &#96;_.object&#96; with one argument.</span><br><span class="line">  function pairs(obj) &#123;</span><br><span class="line">    var _keys &#x3D; keys(obj);</span><br><span class="line">    var length &#x3D; _keys.length;</span><br><span class="line">    var pairs &#x3D; Array(length);</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      pairs[i] &#x3D; [_keys[i], obj[_keys[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    return pairs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Invert the keys and values of an object. The values must be serializable.</span><br><span class="line">  function invert(obj) &#123;</span><br><span class="line">    var result &#x3D; &#123;&#125;;</span><br><span class="line">    var _keys &#x3D; keys(obj);</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; _keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      result[obj[_keys[i]]] &#x3D; _keys[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a sorted list of the function names available on the object.</span><br><span class="line">  function functions(obj) &#123;</span><br><span class="line">    var names &#x3D; [];</span><br><span class="line">    for (var key in obj) &#123;</span><br><span class="line">      if (isFunction$1(obj[key])) names.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    return names.sort();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; An internal function for creating assigner functions.</span><br><span class="line">  function createAssigner(keysFunc, defaults) &#123;</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      var length &#x3D; arguments.length;</span><br><span class="line">      if (defaults) obj &#x3D; Object(obj);</span><br><span class="line">      if (length &lt; 2 || obj &#x3D;&#x3D; null) return obj;</span><br><span class="line">      for (var index &#x3D; 1; index &lt; length; index++) &#123;</span><br><span class="line">        var source &#x3D; arguments[index],</span><br><span class="line">            keys &#x3D; keysFunc(source),</span><br><span class="line">            l &#x3D; keys.length;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">          var key &#x3D; keys[i];</span><br><span class="line">          if (!defaults || obj[key] &#x3D;&#x3D;&#x3D; void 0) obj[key] &#x3D; source[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Extend a given object with all the properties in passed-in object(s).</span><br><span class="line">  var extend &#x3D; createAssigner(allKeys);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Assigns a given object with all the own properties in the passed-in</span><br><span class="line">  &#x2F;&#x2F; object(s).</span><br><span class="line">  &#x2F;&#x2F; (https:&#x2F;&#x2F;developer.mozilla.org&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;assign)</span><br><span class="line">  var extendOwn &#x3D; createAssigner(keys);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Fill in a given object with default properties.</span><br><span class="line">  var defaults &#x3D; createAssigner(allKeys, true);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Create a naked function reference for surrogate-prototype-swapping.</span><br><span class="line">  function ctor() &#123;</span><br><span class="line">    return function()&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; An internal function for creating a new object that inherits from another.</span><br><span class="line">  function baseCreate(prototype) &#123;</span><br><span class="line">    if (!isObject(prototype)) return &#123;&#125;;</span><br><span class="line">    if (nativeCreate) return nativeCreate(prototype);</span><br><span class="line">    var Ctor &#x3D; ctor();</span><br><span class="line">    Ctor.prototype &#x3D; prototype;</span><br><span class="line">    var result &#x3D; new Ctor;</span><br><span class="line">    Ctor.prototype &#x3D; null;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Creates an object that inherits from the given prototype object.</span><br><span class="line">  &#x2F;&#x2F; If additional properties are provided then they will be added to the</span><br><span class="line">  &#x2F;&#x2F; created object.</span><br><span class="line">  function create(prototype, props) &#123;</span><br><span class="line">    var result &#x3D; baseCreate(prototype);</span><br><span class="line">    if (props) extendOwn(result, props);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Create a (shallow-cloned) duplicate of an object.</span><br><span class="line">  function clone(obj) &#123;</span><br><span class="line">    if (!isObject(obj)) return obj;</span><br><span class="line">    return isArray(obj) ? obj.slice() : extend(&#123;&#125;, obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Invokes &#96;interceptor&#96; with the &#96;obj&#96; and then returns &#96;obj&#96;.</span><br><span class="line">  &#x2F;&#x2F; The primary purpose of this method is to &quot;tap into&quot; a method chain, in</span><br><span class="line">  &#x2F;&#x2F; order to perform operations on intermediate results within the chain.</span><br><span class="line">  function tap(obj, interceptor) &#123;</span><br><span class="line">    interceptor(obj);</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Normalize a (deep) property &#96;path&#96; to array.</span><br><span class="line">  &#x2F;&#x2F; Like &#96;_.iteratee&#96;, this function can be customized.</span><br><span class="line">  function toPath$1(path) &#123;</span><br><span class="line">    return isArray(path) ? path : [path];</span><br><span class="line">  &#125;</span><br><span class="line">  _$1.toPath &#x3D; toPath$1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal wrapper for &#96;_.toPath&#96; to enable minification.</span><br><span class="line">  &#x2F;&#x2F; Similar to &#96;cb&#96; for &#96;_.iteratee&#96;.</span><br><span class="line">  function toPath(path) &#123;</span><br><span class="line">    return _$1.toPath(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function to obtain a nested property in &#96;obj&#96; along &#96;path&#96;.</span><br><span class="line">  function deepGet(obj, path) &#123;</span><br><span class="line">    var length &#x3D; path.length;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      if (obj &#x3D;&#x3D; null) return void 0;</span><br><span class="line">      obj &#x3D; obj[path[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    return length ? obj : void 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Get the value of the (deep) property on &#96;path&#96; from &#96;object&#96;.</span><br><span class="line">  &#x2F;&#x2F; If any property in &#96;path&#96; does not exist or if the value is</span><br><span class="line">  &#x2F;&#x2F; &#96;undefined&#96;, return &#96;defaultValue&#96; instead.</span><br><span class="line">  &#x2F;&#x2F; The &#96;path&#96; is normalized through &#96;_.toPath&#96;.</span><br><span class="line">  function get(object, path, defaultValue) &#123;</span><br><span class="line">    var value &#x3D; deepGet(object, toPath(path));</span><br><span class="line">    return isUndefined(value) ? defaultValue : value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Shortcut function for checking if an object has a given property directly on</span><br><span class="line">  &#x2F;&#x2F; itself (in other words, not on a prototype). Unlike the internal &#96;has&#96;</span><br><span class="line">  &#x2F;&#x2F; function, this public version can also traverse nested properties.</span><br><span class="line">  function has(obj, path) &#123;</span><br><span class="line">    path &#x3D; toPath(path);</span><br><span class="line">    var length &#x3D; path.length;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      var key &#x3D; path[i];</span><br><span class="line">      if (!has$1(obj, key)) return false;</span><br><span class="line">      obj &#x3D; obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    return !!length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Keep the identity function around for default iteratees.</span><br><span class="line">  function identity(value) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a predicate for checking whether an object has a given set of</span><br><span class="line">  &#x2F;&#x2F; &#96;key:value&#96; pairs.</span><br><span class="line">  function matcher(attrs) &#123;</span><br><span class="line">    attrs &#x3D; extendOwn(&#123;&#125;, attrs);</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      return isMatch(obj, attrs);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Creates a function that, when passed an object, will traverse that object’s</span><br><span class="line">  &#x2F;&#x2F; properties down the given &#96;path&#96;, specified as an array of keys or indices.</span><br><span class="line">  function property(path) &#123;</span><br><span class="line">    path &#x3D; toPath(path);</span><br><span class="line">    return function(obj) &#123;</span><br><span class="line">      return deepGet(obj, path);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function that returns an efficient (for current engines) version</span><br><span class="line">  &#x2F;&#x2F; of the passed-in callback, to be repeatedly applied in other Underscore</span><br><span class="line">  &#x2F;&#x2F; functions.</span><br><span class="line">  function optimizeCb(func, context, argCount) &#123;</span><br><span class="line">    if (context &#x3D;&#x3D;&#x3D; void 0) return func;</span><br><span class="line">    switch (argCount &#x3D;&#x3D; null ? 3 : argCount) &#123;</span><br><span class="line">      case 1: return function(value) &#123;</span><br><span class="line">        return func.call(context, value);</span><br><span class="line">      &#125;;</span><br><span class="line">      &#x2F;&#x2F; The 2-argument case is omitted because we’re not using it.</span><br><span class="line">      case 3: return function(value, index, collection) &#123;</span><br><span class="line">        return func.call(context, value, index, collection);</span><br><span class="line">      &#125;;</span><br><span class="line">      case 4: return function(accumulator, value, index, collection) &#123;</span><br><span class="line">        return func.call(context, accumulator, value, index, collection);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      return func.apply(context, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; An internal function to generate callbacks that can be applied to each</span><br><span class="line">  &#x2F;&#x2F; element in a collection, returning the desired result — either &#96;_.identity&#96;,</span><br><span class="line">  &#x2F;&#x2F; an arbitrary callback, a property matcher, or a property accessor.</span><br><span class="line">  function baseIteratee(value, context, argCount) &#123;</span><br><span class="line">    if (value &#x3D;&#x3D; null) return identity;</span><br><span class="line">    if (isFunction$1(value)) return optimizeCb(value, context, argCount);</span><br><span class="line">    if (isObject(value) &amp;&amp; !isArray(value)) return matcher(value);</span><br><span class="line">    return property(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; External wrapper for our callback generator. Users may customize</span><br><span class="line">  &#x2F;&#x2F; &#96;_.iteratee&#96; if they want additional predicate&#x2F;iteratee shorthand styles.</span><br><span class="line">  &#x2F;&#x2F; This abstraction hides the internal-only &#96;argCount&#96; argument.</span><br><span class="line">  function iteratee(value, context) &#123;</span><br><span class="line">    return baseIteratee(value, context, Infinity);</span><br><span class="line">  &#125;</span><br><span class="line">  _$1.iteratee &#x3D; iteratee;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The function we call internally to generate a callback. It invokes</span><br><span class="line">  &#x2F;&#x2F; &#96;_.iteratee&#96; if overridden, otherwise &#96;baseIteratee&#96;.</span><br><span class="line">  function cb(value, context, argCount) &#123;</span><br><span class="line">    if (_$1.iteratee !&#x3D;&#x3D; iteratee) return _$1.iteratee(value, context);</span><br><span class="line">    return baseIteratee(value, context, argCount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns the results of applying the &#96;iteratee&#96; to each element of &#96;obj&#96;.</span><br><span class="line">  &#x2F;&#x2F; In contrast to &#96;_.map&#96; it returns an object.</span><br><span class="line">  function mapObject(obj, iteratee, context) &#123;</span><br><span class="line">    iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">    var _keys &#x3D; keys(obj),</span><br><span class="line">        length &#x3D; _keys.length,</span><br><span class="line">        results &#x3D; &#123;&#125;;</span><br><span class="line">    for (var index &#x3D; 0; index &lt; length; index++) &#123;</span><br><span class="line">      var currentKey &#x3D; _keys[index];</span><br><span class="line">      results[currentKey] &#x3D; iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return results;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Predicate-generating function. Often useful outside of Underscore.</span><br><span class="line">  function noop()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Generates a function for a given object that returns a given property.</span><br><span class="line">  function propertyOf(obj) &#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) return noop;</span><br><span class="line">    return function(path) &#123;</span><br><span class="line">      return get(obj, path);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Run a function **n** times.</span><br><span class="line">  function times(n, iteratee, context) &#123;</span><br><span class="line">    var accum &#x3D; Array(Math.max(0, n));</span><br><span class="line">    iteratee &#x3D; optimizeCb(iteratee, context, 1);</span><br><span class="line">    for (var i &#x3D; 0; i &lt; n; i++) accum[i] &#x3D; iteratee(i);</span><br><span class="line">    return accum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a random integer between &#96;min&#96; and &#96;max&#96; (inclusive).</span><br><span class="line">  function random(min, max) &#123;</span><br><span class="line">    if (max &#x3D;&#x3D; null) &#123;</span><br><span class="line">      max &#x3D; min;</span><br><span class="line">      min &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return min + Math.floor(Math.random() * (max - min + 1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; A (possibly faster) way to get the current timestamp as an integer.</span><br><span class="line">  var now &#x3D; Date.now || function() &#123;</span><br><span class="line">    return new Date().getTime();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to generate functions for escaping and unescaping strings</span><br><span class="line">  &#x2F;&#x2F; to&#x2F;from HTML interpolation.</span><br><span class="line">  function createEscaper(map) &#123;</span><br><span class="line">    var escaper &#x3D; function(match) &#123;</span><br><span class="line">      return map[match];</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; Regexes for identifying a key that needs to be escaped.</span><br><span class="line">    var source &#x3D; &#39;(?:&#39; + keys(map).join(&#39;|&#39;) + &#39;)&#39;;</span><br><span class="line">    var testRegexp &#x3D; RegExp(source);</span><br><span class="line">    var replaceRegexp &#x3D; RegExp(source, &#39;g&#39;);</span><br><span class="line">    return function(string) &#123;</span><br><span class="line">      string &#x3D; string &#x3D;&#x3D; null ? &#39;&#39; : &#39;&#39; + string;</span><br><span class="line">      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal list of HTML entities for escaping.</span><br><span class="line">  var escapeMap &#x3D; &#123;</span><br><span class="line">    &#39;&amp;&#39;: &#39;&amp;&#39;,</span><br><span class="line">    &#39;&lt;&#39;: &#39;&lt;&#39;,</span><br><span class="line">    &#39;&gt;&#39;: &#39;&gt;&#39;,</span><br><span class="line">    &#39;&quot;&#39;: &#39;&quot;&#39;,</span><br><span class="line">    &quot;&#39;&quot;: &#39;&amp;#x27;&#39;,</span><br><span class="line">    &#39;&#96;&#39;: &#39;&amp;#x60;&#39;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Function for escaping strings to HTML interpolation.</span><br><span class="line">  var _escape &#x3D; createEscaper(escapeMap);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal list of HTML entities for unescaping.</span><br><span class="line">  var unescapeMap &#x3D; invert(escapeMap);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Function for unescaping strings from HTML interpolation.</span><br><span class="line">  var _unescape &#x3D; createEscaper(unescapeMap);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; By default, Underscore uses ERB-style template delimiters. Change the</span><br><span class="line">  &#x2F;&#x2F; following template settings to use alternative delimiters.</span><br><span class="line">  var templateSettings &#x3D; _$1.templateSettings &#x3D; &#123;</span><br><span class="line">    evaluate: &#x2F;&lt;%([\s\S]+?)%&gt;&#x2F;g,</span><br><span class="line">    interpolate: &#x2F;&lt;%&#x3D;([\s\S]+?)%&gt;&#x2F;g,</span><br><span class="line">    escape: &#x2F;&lt;%-([\s\S]+?)%&gt;&#x2F;g</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; When customizing &#96;_.templateSettings&#96;, if you don&#39;t want to define an</span><br><span class="line">  &#x2F;&#x2F; interpolation, evaluation or escaping regex, we need one that is</span><br><span class="line">  &#x2F;&#x2F; guaranteed not to match.</span><br><span class="line">  var noMatch &#x3D; &#x2F;(.)^&#x2F;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Certain characters need to be escaped so that they can be put into a</span><br><span class="line">  &#x2F;&#x2F; string literal.</span><br><span class="line">  var escapes &#x3D; &#123;</span><br><span class="line">    &quot;&#39;&quot;: &quot;&#39;&quot;,</span><br><span class="line">    &#39;\\&#39;: &#39;\\&#39;,</span><br><span class="line">    &#39;\r&#39;: &#39;r&#39;,</span><br><span class="line">    &#39;\n&#39;: &#39;n&#39;,</span><br><span class="line">    &#39;\u2028&#39;: &#39;u2028&#39;,</span><br><span class="line">    &#39;\u2029&#39;: &#39;u2029&#39;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var escapeRegExp &#x3D; &#x2F;\\|&#39;|\r|\n|\u2028|\u2029&#x2F;g;</span><br><span class="line"></span><br><span class="line">  function escapeChar(match) &#123;</span><br><span class="line">    return &#39;\\&#39; + escapes[match];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; In order to prevent third-party code injection through</span><br><span class="line">  &#x2F;&#x2F; &#96;_.templateSettings.variable&#96;, we test it against the following regular</span><br><span class="line">  &#x2F;&#x2F; expression. It is intentionally a bit more liberal than just matching valid</span><br><span class="line">  &#x2F;&#x2F; identifiers, but still prevents possible loopholes through defaults or</span><br><span class="line">  &#x2F;&#x2F; destructuring assignment.</span><br><span class="line">  var bareIdentifier &#x3D; &#x2F;^\s*(\w|\$)+\s*$&#x2F;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; JavaScript micro-templating, similar to John Resig&#39;s implementation.</span><br><span class="line">  &#x2F;&#x2F; Underscore templating handles arbitrary delimiters, preserves whitespace,</span><br><span class="line">  &#x2F;&#x2F; and correctly escapes quotes within interpolated code.</span><br><span class="line">  &#x2F;&#x2F; NB: &#96;oldSettings&#96; only exists for backwards compatibility.</span><br><span class="line">  function template(text, settings, oldSettings) &#123;</span><br><span class="line">    if (!settings &amp;&amp; oldSettings) settings &#x3D; oldSettings;</span><br><span class="line">    settings &#x3D; defaults(&#123;&#125;, settings, _$1.templateSettings);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Combine delimiters into one regular expression via alternation.</span><br><span class="line">    var matcher &#x3D; RegExp([</span><br><span class="line">      (settings.escape || noMatch).source,</span><br><span class="line">      (settings.interpolate || noMatch).source,</span><br><span class="line">      (settings.evaluate || noMatch).source</span><br><span class="line">    ].join(&#39;|&#39;) + &#39;|$&#39;, &#39;g&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Compile the template source, escaping string literals appropriately.</span><br><span class="line">    var index &#x3D; 0;</span><br><span class="line">    var source &#x3D; &quot;__p+&#x3D;&#39;&quot;;</span><br><span class="line">    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) &#123;</span><br><span class="line">      source +&#x3D; text.slice(index, offset).replace(escapeRegExp, escapeChar);</span><br><span class="line">      index &#x3D; offset + match.length;</span><br><span class="line"></span><br><span class="line">      if (escape) &#123;</span><br><span class="line">        source +&#x3D; &quot;&#39;+\n((__t&#x3D;(&quot; + escape + &quot;))&#x3D;&#x3D;null?&#39;&#39;:_.escape(__t))+\n&#39;&quot;;</span><br><span class="line">      &#125; else if (interpolate) &#123;</span><br><span class="line">        source +&#x3D; &quot;&#39;+\n((__t&#x3D;(&quot; + interpolate + &quot;))&#x3D;&#x3D;null?&#39;&#39;:__t)+\n&#39;&quot;;</span><br><span class="line">      &#125; else if (evaluate) &#123;</span><br><span class="line">        source +&#x3D; &quot;&#39;;\n&quot; + evaluate + &quot;\n__p+&#x3D;&#39;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Adobe VMs need the match returned to produce the correct offset.</span><br><span class="line">      return match;</span><br><span class="line">    &#125;);</span><br><span class="line">    source +&#x3D; &quot;&#39;;\n&quot;;</span><br><span class="line"></span><br><span class="line">    var argument &#x3D; settings.variable;</span><br><span class="line">    if (argument) &#123;</span><br><span class="line">      &#x2F;&#x2F; Insure against third-party code injection. (CVE-2021-23358)</span><br><span class="line">      if (!bareIdentifier.test(argument)) throw new Error(</span><br><span class="line">        &#39;variable is not a bare identifier: &#39; + argument</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; If a variable is not specified, place data values in local scope.</span><br><span class="line">      source &#x3D; &#39;with(obj||&#123;&#125;)&#123;\n&#39; + source + &#39;&#125;\n&#39;;</span><br><span class="line">      argument &#x3D; &#39;obj&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    source &#x3D; &quot;var __t,__p&#x3D;&#39;&#39;,__j&#x3D;Array.prototype.join,&quot; +</span><br><span class="line">      &quot;print&#x3D;function()&#123;__p+&#x3D;__j.call(arguments,&#39;&#39;);&#125;;\n&quot; +</span><br><span class="line">      source + &#39;return __p;\n&#39;;</span><br><span class="line"></span><br><span class="line">    var render;</span><br><span class="line">    try &#123;</span><br><span class="line">      render &#x3D; new Function(argument, &#39;_&#39;, source);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      e.source &#x3D; source;</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var template &#x3D; function(data) &#123;</span><br><span class="line">      return render.call(this, data, _$1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Provide the compiled source as a convenience for precompilation.</span><br><span class="line">    template.source &#x3D; &#39;function(&#39; + argument + &#39;)&#123;\n&#39; + source + &#39;&#125;&#39;;</span><br><span class="line"></span><br><span class="line">    return template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Traverses the children of &#96;obj&#96; along &#96;path&#96;. If a child is a function, it</span><br><span class="line">  &#x2F;&#x2F; is invoked with its parent as context. Returns the value of the final</span><br><span class="line">  &#x2F;&#x2F; child, or &#96;fallback&#96; if any child is undefined.</span><br><span class="line">  function result(obj, path, fallback) &#123;</span><br><span class="line">    path &#x3D; toPath(path);</span><br><span class="line">    var length &#x3D; path.length;</span><br><span class="line">    if (!length) &#123;</span><br><span class="line">      return isFunction$1(fallback) ? fallback.call(obj) : fallback;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      var prop &#x3D; obj &#x3D;&#x3D; null ? void 0 : obj[path[i]];</span><br><span class="line">      if (prop &#x3D;&#x3D;&#x3D; void 0) &#123;</span><br><span class="line">        prop &#x3D; fallback;</span><br><span class="line">        i &#x3D; length; &#x2F;&#x2F; Ensure we don&#39;t continue iterating.</span><br><span class="line">      &#125;</span><br><span class="line">      obj &#x3D; isFunction$1(prop) ? prop.call(obj) : prop;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Generate a unique integer id (unique within the entire client session).</span><br><span class="line">  &#x2F;&#x2F; Useful for temporary DOM ids.</span><br><span class="line">  var idCounter &#x3D; 0;</span><br><span class="line">  function uniqueId(prefix) &#123;</span><br><span class="line">    var id &#x3D; ++idCounter + &#39;&#39;;</span><br><span class="line">    return prefix ? prefix + id : id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Start chaining a wrapped Underscore object.</span><br><span class="line">  function chain(obj) &#123;</span><br><span class="line">    var instance &#x3D; _$1(obj);</span><br><span class="line">    instance._chain &#x3D; true;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function to execute &#96;sourceFunc&#96; bound to &#96;context&#96; with optional</span><br><span class="line">  &#x2F;&#x2F; &#96;args&#96;. Determines whether to execute a function as a constructor or as a</span><br><span class="line">  &#x2F;&#x2F; normal function.</span><br><span class="line">  function executeBound(sourceFunc, boundFunc, context, callingContext, args) &#123;</span><br><span class="line">    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);</span><br><span class="line">    var self &#x3D; baseCreate(sourceFunc.prototype);</span><br><span class="line">    var result &#x3D; sourceFunc.apply(self, args);</span><br><span class="line">    if (isObject(result)) return result;</span><br><span class="line">    return self;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Partially apply a function by creating a version that has had some of its</span><br><span class="line">  &#x2F;&#x2F; arguments pre-filled, without changing its dynamic &#96;this&#96; context. &#96;_&#96; acts</span><br><span class="line">  &#x2F;&#x2F; as a placeholder by default, allowing any combination of arguments to be</span><br><span class="line">  &#x2F;&#x2F; pre-filled. Set &#96;_.partial.placeholder&#96; for a custom placeholder argument.</span><br><span class="line">  var partial &#x3D; restArguments(function(func, boundArgs) &#123;</span><br><span class="line">    var placeholder &#x3D; partial.placeholder;</span><br><span class="line">    var bound &#x3D; function() &#123;</span><br><span class="line">      var position &#x3D; 0, length &#x3D; boundArgs.length;</span><br><span class="line">      var args &#x3D; Array(length);</span><br><span class="line">      for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">        args[i] &#x3D; boundArgs[i] &#x3D;&#x3D;&#x3D; placeholder ? arguments[position++] : boundArgs[i];</span><br><span class="line">      &#125;</span><br><span class="line">      while (position &lt; arguments.length) args.push(arguments[position++]);</span><br><span class="line">      return executeBound(func, bound, this, this, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    return bound;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  partial.placeholder &#x3D; _$1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Create a function bound to a given object (assigning &#96;this&#96;, and arguments,</span><br><span class="line">  &#x2F;&#x2F; optionally).</span><br><span class="line">  var bind &#x3D; restArguments(function(func, context, args) &#123;</span><br><span class="line">    if (!isFunction$1(func)) throw new TypeError(&#39;Bind must be called on a function&#39;);</span><br><span class="line">    var bound &#x3D; restArguments(function(callArgs) &#123;</span><br><span class="line">      return executeBound(func, bound, context, this, args.concat(callArgs));</span><br><span class="line">    &#125;);</span><br><span class="line">    return bound;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper for collection methods to determine whether a collection</span><br><span class="line">  &#x2F;&#x2F; should be iterated as an array or as an object.</span><br><span class="line">  &#x2F;&#x2F; Related: https:&#x2F;&#x2F;people.mozilla.org&#x2F;~jorendorff&#x2F;es6-draft.html#sec-tolength</span><br><span class="line">  &#x2F;&#x2F; Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094</span><br><span class="line">  var isArrayLike &#x3D; createSizePropertyCheck(getLength);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal implementation of a recursive &#96;flatten&#96; function.</span><br><span class="line">  function flatten$1(input, depth, strict, output) &#123;</span><br><span class="line">    output &#x3D; output || [];</span><br><span class="line">    if (!depth &amp;&amp; depth !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      depth &#x3D; Infinity;</span><br><span class="line">    &#125; else if (depth &lt;&#x3D; 0) &#123;</span><br><span class="line">      return output.concat(input);</span><br><span class="line">    &#125;</span><br><span class="line">    var idx &#x3D; output.length;</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; getLength(input); i &lt; length; i++) &#123;</span><br><span class="line">      var value &#x3D; input[i];</span><br><span class="line">      if (isArrayLike(value) &amp;&amp; (isArray(value) || isArguments$1(value))) &#123;</span><br><span class="line">        &#x2F;&#x2F; Flatten current level of array or arguments object.</span><br><span class="line">        if (depth &gt; 1) &#123;</span><br><span class="line">          flatten$1(value, depth - 1, strict, output);</span><br><span class="line">          idx &#x3D; output.length;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          var j &#x3D; 0, len &#x3D; value.length;</span><br><span class="line">          while (j &lt; len) output[idx++] &#x3D; value[j++];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (!strict) &#123;</span><br><span class="line">        output[idx++] &#x3D; value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return output;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Bind a number of an object&#39;s methods to that object. Remaining arguments</span><br><span class="line">  &#x2F;&#x2F; are the method names to be bound. Useful for ensuring that all callbacks</span><br><span class="line">  &#x2F;&#x2F; defined on an object belong to it.</span><br><span class="line">  var bindAll &#x3D; restArguments(function(obj, keys) &#123;</span><br><span class="line">    keys &#x3D; flatten$1(keys, false, false);</span><br><span class="line">    var index &#x3D; keys.length;</span><br><span class="line">    if (index &lt; 1) throw new Error(&#39;bindAll must be passed function names&#39;);</span><br><span class="line">    while (index--) &#123;</span><br><span class="line">      var key &#x3D; keys[index];</span><br><span class="line">      obj[key] &#x3D; bind(obj[key], obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Memoize an expensive function by storing its results.</span><br><span class="line">  function memoize(func, hasher) &#123;</span><br><span class="line">    var memoize &#x3D; function(key) &#123;</span><br><span class="line">      var cache &#x3D; memoize.cache;</span><br><span class="line">      var address &#x3D; &#39;&#39; + (hasher ? hasher.apply(this, arguments) : key);</span><br><span class="line">      if (!has$1(cache, address)) cache[address] &#x3D; func.apply(this, arguments);</span><br><span class="line">      return cache[address];</span><br><span class="line">    &#125;;</span><br><span class="line">    memoize.cache &#x3D; &#123;&#125;;</span><br><span class="line">    return memoize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Delays a function for the given number of milliseconds, and then calls</span><br><span class="line">  &#x2F;&#x2F; it with the arguments supplied.</span><br><span class="line">  var delay &#x3D; restArguments(function(func, wait, args) &#123;</span><br><span class="line">    return setTimeout(function() &#123;</span><br><span class="line">      return func.apply(null, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Defers a function, scheduling it to run after the current call stack has</span><br><span class="line">  &#x2F;&#x2F; cleared.</span><br><span class="line">  var defer &#x3D; partial(delay, _$1, 1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a function, that, when invoked, will only be triggered at most once</span><br><span class="line">  &#x2F;&#x2F; during a given window of time. Normally, the throttled function will run</span><br><span class="line">  &#x2F;&#x2F; as much as it can, without ever going more than once per &#96;wait&#96; duration;</span><br><span class="line">  &#x2F;&#x2F; but if you&#39;d like to disable the execution on the leading edge, pass</span><br><span class="line">  &#x2F;&#x2F; &#96;&#123;leading: false&#125;&#96;. To disable execution on the trailing edge, ditto.</span><br><span class="line">  function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    if (!options) options &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">      previous &#x3D; options.leading &#x3D;&#x3D;&#x3D; false ? 0 : now();</span><br><span class="line">      timeout &#x3D; null;</span><br><span class="line">      result &#x3D; func.apply(context, args);</span><br><span class="line">      if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled &#x3D; function() &#123;</span><br><span class="line">      var _now &#x3D; now();</span><br><span class="line">      if (!previous &amp;&amp; options.leading &#x3D;&#x3D;&#x3D; false) previous &#x3D; _now;</span><br><span class="line">      var remaining &#x3D; wait - (_now - previous);</span><br><span class="line">      context &#x3D; this;</span><br><span class="line">      args &#x3D; arguments;</span><br><span class="line">      if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">        if (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        previous &#x3D; _now;</span><br><span class="line">        result &#x3D; func.apply(context, args);</span><br><span class="line">        if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">      &#125; else if (!timeout &amp;&amp; options.trailing !&#x3D;&#x3D; false) &#123;</span><br><span class="line">        timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    throttled.cancel &#x3D; function() &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      previous &#x3D; 0;</span><br><span class="line">      timeout &#x3D; context &#x3D; args &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return throttled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; When a sequence of calls of the returned function ends, the argument</span><br><span class="line">  &#x2F;&#x2F; function is triggered. The end of a sequence is defined by the &#96;wait&#96;</span><br><span class="line">  &#x2F;&#x2F; parameter. If &#96;immediate&#96; is passed, the argument function will be</span><br><span class="line">  &#x2F;&#x2F; triggered at the beginning of the sequence instead of at the end.</span><br><span class="line">  function debounce(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, previous, args, result, context;</span><br><span class="line"></span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">      var passed &#x3D; now() - previous;</span><br><span class="line">      if (wait &gt; passed) &#123;</span><br><span class="line">        timeout &#x3D; setTimeout(later, wait - passed);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        timeout &#x3D; null;</span><br><span class="line">        if (!immediate) result &#x3D; func.apply(context, args);</span><br><span class="line">        &#x2F;&#x2F; This check is needed because &#96;func&#96; can recursively invoke &#96;debounced&#96;.</span><br><span class="line">        if (!timeout) args &#x3D; context &#x3D; null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var debounced &#x3D; restArguments(function(_args) &#123;</span><br><span class="line">      context &#x3D; this;</span><br><span class="line">      args &#x3D; _args;</span><br><span class="line">      previous &#x3D; now();</span><br><span class="line">      if (!timeout) &#123;</span><br><span class="line">        timeout &#x3D; setTimeout(later, wait);</span><br><span class="line">        if (immediate) result &#x3D; func.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    debounced.cancel &#x3D; function() &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      timeout &#x3D; args &#x3D; context &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns the first function passed as an argument to the second,</span><br><span class="line">  &#x2F;&#x2F; allowing you to adjust arguments, run code before and after, and</span><br><span class="line">  &#x2F;&#x2F; conditionally execute the original function.</span><br><span class="line">  function wrap(func, wrapper) &#123;</span><br><span class="line">    return partial(wrapper, func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a negated version of the passed-in predicate.</span><br><span class="line">  function negate(predicate) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      return !predicate.apply(this, arguments);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a function that is the composition of a list of functions, each</span><br><span class="line">  &#x2F;&#x2F; consuming the return value of the function that follows.</span><br><span class="line">  function compose() &#123;</span><br><span class="line">    var args &#x3D; arguments;</span><br><span class="line">    var start &#x3D; args.length - 1;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      var i &#x3D; start;</span><br><span class="line">      var result &#x3D; args[start].apply(this, arguments);</span><br><span class="line">      while (i--) result &#x3D; args[i].call(this, result);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a function that will only be executed on and after the Nth call.</span><br><span class="line">  function after(times, func) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      if (--times &lt; 1) &#123;</span><br><span class="line">        return func.apply(this, arguments);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a function that will only be executed up to (but not including) the</span><br><span class="line">  &#x2F;&#x2F; Nth call.</span><br><span class="line">  function before(times, func) &#123;</span><br><span class="line">    var memo;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      if (--times &gt; 0) &#123;</span><br><span class="line">        memo &#x3D; func.apply(this, arguments);</span><br><span class="line">      &#125;</span><br><span class="line">      if (times &lt;&#x3D; 1) func &#x3D; null;</span><br><span class="line">      return memo;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns a function that will be executed at most one time, no matter how</span><br><span class="line">  &#x2F;&#x2F; often you call it. Useful for lazy initialization.</span><br><span class="line">  var once &#x3D; partial(before, 2);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns the first key on an object that passes a truth test.</span><br><span class="line">  function findKey(obj, predicate, context) &#123;</span><br><span class="line">    predicate &#x3D; cb(predicate, context);</span><br><span class="line">    var _keys &#x3D; keys(obj), key;</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; _keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      key &#x3D; _keys[i];</span><br><span class="line">      if (predicate(obj[key], key, obj)) return key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function to generate &#96;_.findIndex&#96; and &#96;_.findLastIndex&#96;.</span><br><span class="line">  function createPredicateIndexFinder(dir) &#123;</span><br><span class="line">    return function(array, predicate, context) &#123;</span><br><span class="line">      predicate &#x3D; cb(predicate, context);</span><br><span class="line">      var length &#x3D; getLength(array);</span><br><span class="line">      var index &#x3D; dir &gt; 0 ? 0 : length - 1;</span><br><span class="line">      for (; index &gt;&#x3D; 0 &amp;&amp; index &lt; length; index +&#x3D; dir) &#123;</span><br><span class="line">        if (predicate(array[index], index, array)) return index;</span><br><span class="line">      &#125;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns the first index on an array-like that passes a truth test.</span><br><span class="line">  var findIndex &#x3D; createPredicateIndexFinder(1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns the last index on an array-like that passes a truth test.</span><br><span class="line">  var findLastIndex &#x3D; createPredicateIndexFinder(-1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Use a comparator function to figure out the smallest index at which</span><br><span class="line">  &#x2F;&#x2F; an object should be inserted so as to maintain order. Uses binary search.</span><br><span class="line">  function sortedIndex(array, obj, iteratee, context) &#123;</span><br><span class="line">    iteratee &#x3D; cb(iteratee, context, 1);</span><br><span class="line">    var value &#x3D; iteratee(obj);</span><br><span class="line">    var low &#x3D; 0, high &#x3D; getLength(array);</span><br><span class="line">    while (low &lt; high) &#123;</span><br><span class="line">      var mid &#x3D; Math.floor((low + high) &#x2F; 2);</span><br><span class="line">      if (iteratee(array[mid]) &lt; value) low &#x3D; mid + 1; else high &#x3D; mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal function to generate the &#96;_.indexOf&#96; and &#96;_.lastIndexOf&#96; functions.</span><br><span class="line">  function createIndexFinder(dir, predicateFind, sortedIndex) &#123;</span><br><span class="line">    return function(array, item, idx) &#123;</span><br><span class="line">      var i &#x3D; 0, length &#x3D; getLength(array);</span><br><span class="line">      if (typeof idx &#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">        if (dir &gt; 0) &#123;</span><br><span class="line">          i &#x3D; idx &gt;&#x3D; 0 ? idx : Math.max(idx + length, i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          length &#x3D; idx &gt;&#x3D; 0 ? Math.min(idx + 1, length) : idx + length + 1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (sortedIndex &amp;&amp; idx &amp;&amp; length) &#123;</span><br><span class="line">        idx &#x3D; sortedIndex(array, item);</span><br><span class="line">        return array[idx] &#x3D;&#x3D;&#x3D; item ? idx : -1;</span><br><span class="line">      &#125;</span><br><span class="line">      if (item !&#x3D;&#x3D; item) &#123;</span><br><span class="line">        idx &#x3D; predicateFind(slice.call(array, i, length), isNaN$1);</span><br><span class="line">        return idx &gt;&#x3D; 0 ? idx + i : -1;</span><br><span class="line">      &#125;</span><br><span class="line">      for (idx &#x3D; dir &gt; 0 ? i : length - 1; idx &gt;&#x3D; 0 &amp;&amp; idx &lt; length; idx +&#x3D; dir) &#123;</span><br><span class="line">        if (array[idx] &#x3D;&#x3D;&#x3D; item) return idx;</span><br><span class="line">      &#125;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the position of the first occurrence of an item in an array,</span><br><span class="line">  &#x2F;&#x2F; or -1 if the item is not included in the array.</span><br><span class="line">  &#x2F;&#x2F; If the array is large and already in sort order, pass &#96;true&#96;</span><br><span class="line">  &#x2F;&#x2F; for **isSorted** to use binary search.</span><br><span class="line">  var indexOf &#x3D; createIndexFinder(1, findIndex, sortedIndex);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the position of the last occurrence of an item in an array,</span><br><span class="line">  &#x2F;&#x2F; or -1 if the item is not included in the array.</span><br><span class="line">  var lastIndexOf &#x3D; createIndexFinder(-1, findLastIndex);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the first value which passes a truth test.</span><br><span class="line">  function find(obj, predicate, context) &#123;</span><br><span class="line">    var keyFinder &#x3D; isArrayLike(obj) ? findIndex : findKey;</span><br><span class="line">    var key &#x3D; keyFinder(obj, predicate, context);</span><br><span class="line">    if (key !&#x3D;&#x3D; void 0 &amp;&amp; key !&#x3D;&#x3D; -1) return obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Convenience version of a common use case of &#96;_.find&#96;: getting the first</span><br><span class="line">  &#x2F;&#x2F; object containing specific &#96;key:value&#96; pairs.</span><br><span class="line">  function findWhere(obj, attrs) &#123;</span><br><span class="line">    return find(obj, matcher(attrs));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The cornerstone for collection functions, an &#96;each&#96;</span><br><span class="line">  &#x2F;&#x2F; implementation, aka &#96;forEach&#96;.</span><br><span class="line">  &#x2F;&#x2F; Handles raw objects in addition to array-likes. Treats all</span><br><span class="line">  &#x2F;&#x2F; sparse array-likes as if they were dense.</span><br><span class="line">  function each(obj, iteratee, context) &#123;</span><br><span class="line">    iteratee &#x3D; optimizeCb(iteratee, context);</span><br><span class="line">    var i, length;</span><br><span class="line">    if (isArrayLike(obj)) &#123;</span><br><span class="line">      for (i &#x3D; 0, length &#x3D; obj.length; i &lt; length; i++) &#123;</span><br><span class="line">        iteratee(obj[i], i, obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var _keys &#x3D; keys(obj);</span><br><span class="line">      for (i &#x3D; 0, length &#x3D; _keys.length; i &lt; length; i++) &#123;</span><br><span class="line">        iteratee(obj[_keys[i]], _keys[i], obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the results of applying the iteratee to each element.</span><br><span class="line">  function map(obj, iteratee, context) &#123;</span><br><span class="line">    iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">    var _keys &#x3D; !isArrayLike(obj) &amp;&amp; keys(obj),</span><br><span class="line">        length &#x3D; (_keys || obj).length,</span><br><span class="line">        results &#x3D; Array(length);</span><br><span class="line">    for (var index &#x3D; 0; index &lt; length; index++) &#123;</span><br><span class="line">      var currentKey &#x3D; _keys ? _keys[index] : index;</span><br><span class="line">      results[index] &#x3D; iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return results;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal helper to create a reducing function, iterating left or right.</span><br><span class="line">  function createReduce(dir) &#123;</span><br><span class="line">    &#x2F;&#x2F; Wrap code that reassigns argument variables in a separate function than</span><br><span class="line">    &#x2F;&#x2F; the one that accesses &#96;arguments.length&#96; to avoid a perf hit. (#1991)</span><br><span class="line">    var reducer &#x3D; function(obj, iteratee, memo, initial) &#123;</span><br><span class="line">      var _keys &#x3D; !isArrayLike(obj) &amp;&amp; keys(obj),</span><br><span class="line">          length &#x3D; (_keys || obj).length,</span><br><span class="line">          index &#x3D; dir &gt; 0 ? 0 : length - 1;</span><br><span class="line">      if (!initial) &#123;</span><br><span class="line">        memo &#x3D; obj[_keys ? _keys[index] : index];</span><br><span class="line">        index +&#x3D; dir;</span><br><span class="line">      &#125;</span><br><span class="line">      for (; index &gt;&#x3D; 0 &amp;&amp; index &lt; length; index +&#x3D; dir) &#123;</span><br><span class="line">        var currentKey &#x3D; _keys ? _keys[index] : index;</span><br><span class="line">        memo &#x3D; iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">      &#125;</span><br><span class="line">      return memo;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return function(obj, iteratee, memo, context) &#123;</span><br><span class="line">      var initial &#x3D; arguments.length &gt;&#x3D; 3;</span><br><span class="line">      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; **Reduce** builds up a single result from a list of values, aka &#96;inject&#96;,</span><br><span class="line">  &#x2F;&#x2F; or &#96;foldl&#96;.</span><br><span class="line">  var reduce &#x3D; createReduce(1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; The right-associative version of reduce, also known as &#96;foldr&#96;.</span><br><span class="line">  var reduceRight &#x3D; createReduce(-1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return all the elements that pass a truth test.</span><br><span class="line">  function filter(obj, predicate, context) &#123;</span><br><span class="line">    var results &#x3D; [];</span><br><span class="line">    predicate &#x3D; cb(predicate, context);</span><br><span class="line">    each(obj, function(value, index, list) &#123;</span><br><span class="line">      if (predicate(value, index, list)) results.push(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    return results;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return all the elements for which a truth test fails.</span><br><span class="line">  function reject(obj, predicate, context) &#123;</span><br><span class="line">    return filter(obj, negate(cb(predicate)), context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Determine whether all of the elements pass a truth test.</span><br><span class="line">  function every(obj, predicate, context) &#123;</span><br><span class="line">    predicate &#x3D; cb(predicate, context);</span><br><span class="line">    var _keys &#x3D; !isArrayLike(obj) &amp;&amp; keys(obj),</span><br><span class="line">        length &#x3D; (_keys || obj).length;</span><br><span class="line">    for (var index &#x3D; 0; index &lt; length; index++) &#123;</span><br><span class="line">      var currentKey &#x3D; _keys ? _keys[index] : index;</span><br><span class="line">      if (!predicate(obj[currentKey], currentKey, obj)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Determine if at least one element in the object passes a truth test.</span><br><span class="line">  function some(obj, predicate, context) &#123;</span><br><span class="line">    predicate &#x3D; cb(predicate, context);</span><br><span class="line">    var _keys &#x3D; !isArrayLike(obj) &amp;&amp; keys(obj),</span><br><span class="line">        length &#x3D; (_keys || obj).length;</span><br><span class="line">    for (var index &#x3D; 0; index &lt; length; index++) &#123;</span><br><span class="line">      var currentKey &#x3D; _keys ? _keys[index] : index;</span><br><span class="line">      if (predicate(obj[currentKey], currentKey, obj)) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Determine if the array or object contains a given item (using &#96;&#x3D;&#x3D;&#x3D;&#96;).</span><br><span class="line">  function contains(obj, item, fromIndex, guard) &#123;</span><br><span class="line">    if (!isArrayLike(obj)) obj &#x3D; values(obj);</span><br><span class="line">    if (typeof fromIndex !&#x3D; &#39;number&#39; || guard) fromIndex &#x3D; 0;</span><br><span class="line">    return indexOf(obj, item, fromIndex) &gt;&#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Invoke a method (with arguments) on every item in a collection.</span><br><span class="line">  var invoke &#x3D; restArguments(function(obj, path, args) &#123;</span><br><span class="line">    var contextPath, func;</span><br><span class="line">    if (isFunction$1(path)) &#123;</span><br><span class="line">      func &#x3D; path;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      path &#x3D; toPath(path);</span><br><span class="line">      contextPath &#x3D; path.slice(0, -1);</span><br><span class="line">      path &#x3D; path[path.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return map(obj, function(context) &#123;</span><br><span class="line">      var method &#x3D; func;</span><br><span class="line">      if (!method) &#123;</span><br><span class="line">        if (contextPath &amp;&amp; contextPath.length) &#123;</span><br><span class="line">          context &#x3D; deepGet(context, contextPath);</span><br><span class="line">        &#125;</span><br><span class="line">        if (context &#x3D;&#x3D; null) return void 0;</span><br><span class="line">        method &#x3D; context[path];</span><br><span class="line">      &#125;</span><br><span class="line">      return method &#x3D;&#x3D; null ? method : method.apply(context, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Convenience version of a common use case of &#96;_.map&#96;: fetching a property.</span><br><span class="line">  function pluck(obj, key) &#123;</span><br><span class="line">    return map(obj, property(key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Convenience version of a common use case of &#96;_.filter&#96;: selecting only</span><br><span class="line">  &#x2F;&#x2F; objects containing specific &#96;key:value&#96; pairs.</span><br><span class="line">  function where(obj, attrs) &#123;</span><br><span class="line">    return filter(obj, matcher(attrs));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the maximum element (or element-based computation).</span><br><span class="line">  function max(obj, iteratee, context) &#123;</span><br><span class="line">    var result &#x3D; -Infinity, lastComputed &#x3D; -Infinity,</span><br><span class="line">        value, computed;</span><br><span class="line">    if (iteratee &#x3D;&#x3D; null || typeof iteratee &#x3D;&#x3D; &#39;number&#39; &amp;&amp; typeof obj[0] !&#x3D; &#39;object&#39; &amp;&amp; obj !&#x3D; null) &#123;</span><br><span class="line">      obj &#x3D; isArrayLike(obj) ? obj : values(obj);</span><br><span class="line">      for (var i &#x3D; 0, length &#x3D; obj.length; i &lt; length; i++) &#123;</span><br><span class="line">        value &#x3D; obj[i];</span><br><span class="line">        if (value !&#x3D; null &amp;&amp; value &gt; result) &#123;</span><br><span class="line">          result &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">      each(obj, function(v, index, list) &#123;</span><br><span class="line">        computed &#x3D; iteratee(v, index, list);</span><br><span class="line">        if (computed &gt; lastComputed || computed &#x3D;&#x3D;&#x3D; -Infinity &amp;&amp; result &#x3D;&#x3D;&#x3D; -Infinity) &#123;</span><br><span class="line">          result &#x3D; v;</span><br><span class="line">          lastComputed &#x3D; computed;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the minimum element (or element-based computation).</span><br><span class="line">  function min(obj, iteratee, context) &#123;</span><br><span class="line">    var result &#x3D; Infinity, lastComputed &#x3D; Infinity,</span><br><span class="line">        value, computed;</span><br><span class="line">    if (iteratee &#x3D;&#x3D; null || typeof iteratee &#x3D;&#x3D; &#39;number&#39; &amp;&amp; typeof obj[0] !&#x3D; &#39;object&#39; &amp;&amp; obj !&#x3D; null) &#123;</span><br><span class="line">      obj &#x3D; isArrayLike(obj) ? obj : values(obj);</span><br><span class="line">      for (var i &#x3D; 0, length &#x3D; obj.length; i &lt; length; i++) &#123;</span><br><span class="line">        value &#x3D; obj[i];</span><br><span class="line">        if (value !&#x3D; null &amp;&amp; value &lt; result) &#123;</span><br><span class="line">          result &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">      each(obj, function(v, index, list) &#123;</span><br><span class="line">        computed &#x3D; iteratee(v, index, list);</span><br><span class="line">        if (computed &lt; lastComputed || computed &#x3D;&#x3D;&#x3D; Infinity &amp;&amp; result &#x3D;&#x3D;&#x3D; Infinity) &#123;</span><br><span class="line">          result &#x3D; v;</span><br><span class="line">          lastComputed &#x3D; computed;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Safely create a real, live array from anything iterable.</span><br><span class="line">  var reStrSymbol &#x3D; &#x2F;[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]&#x2F;g;</span><br><span class="line">  function toArray(obj) &#123;</span><br><span class="line">    if (!obj) return [];</span><br><span class="line">    if (isArray(obj)) return slice.call(obj);</span><br><span class="line">    if (isString(obj)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Keep surrogate pair characters together.</span><br><span class="line">      return obj.match(reStrSymbol);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isArrayLike(obj)) return map(obj, identity);</span><br><span class="line">    return values(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Sample **n** random values from a collection using the modern version of the</span><br><span class="line">  &#x2F;&#x2F; [Fisher-Yates shuffle](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Fisher–Yates_shuffle).</span><br><span class="line">  &#x2F;&#x2F; If **n** is not specified, returns a single random element.</span><br><span class="line">  &#x2F;&#x2F; The internal &#96;guard&#96; argument allows it to work with &#96;_.map&#96;.</span><br><span class="line">  function sample(obj, n, guard) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; null || guard) &#123;</span><br><span class="line">      if (!isArrayLike(obj)) obj &#x3D; values(obj);</span><br><span class="line">      return obj[random(obj.length - 1)];</span><br><span class="line">    &#125;</span><br><span class="line">    var sample &#x3D; toArray(obj);</span><br><span class="line">    var length &#x3D; getLength(sample);</span><br><span class="line">    n &#x3D; Math.max(Math.min(n, length), 0);</span><br><span class="line">    var last &#x3D; length - 1;</span><br><span class="line">    for (var index &#x3D; 0; index &lt; n; index++) &#123;</span><br><span class="line">      var rand &#x3D; random(index, last);</span><br><span class="line">      var temp &#x3D; sample[index];</span><br><span class="line">      sample[index] &#x3D; sample[rand];</span><br><span class="line">      sample[rand] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return sample.slice(0, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Shuffle a collection.</span><br><span class="line">  function shuffle(obj) &#123;</span><br><span class="line">    return sample(obj, Infinity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Sort the object&#39;s values by a criterion produced by an iteratee.</span><br><span class="line">  function sortBy(obj, iteratee, context) &#123;</span><br><span class="line">    var index &#x3D; 0;</span><br><span class="line">    iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">    return pluck(map(obj, function(value, key, list) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        value: value,</span><br><span class="line">        index: index++,</span><br><span class="line">        criteria: iteratee(value, key, list)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;).sort(function(left, right) &#123;</span><br><span class="line">      var a &#x3D; left.criteria;</span><br><span class="line">      var b &#x3D; right.criteria;</span><br><span class="line">      if (a !&#x3D;&#x3D; b) &#123;</span><br><span class="line">        if (a &gt; b || a &#x3D;&#x3D;&#x3D; void 0) return 1;</span><br><span class="line">        if (a &lt; b || b &#x3D;&#x3D;&#x3D; void 0) return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      return left.index - right.index;</span><br><span class="line">    &#125;), &#39;value&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; An internal function used for aggregate &quot;group by&quot; operations.</span><br><span class="line">  function group(behavior, partition) &#123;</span><br><span class="line">    return function(obj, iteratee, context) &#123;</span><br><span class="line">      var result &#x3D; partition ? [[], []] : &#123;&#125;;</span><br><span class="line">      iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">      each(obj, function(value, index) &#123;</span><br><span class="line">        var key &#x3D; iteratee(value, index, obj);</span><br><span class="line">        behavior(result, value, key);</span><br><span class="line">      &#125;);</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Groups the object&#39;s values by a criterion. Pass either a string attribute</span><br><span class="line">  &#x2F;&#x2F; to group by, or a function that returns the criterion.</span><br><span class="line">  var groupBy &#x3D; group(function(result, value, key) &#123;</span><br><span class="line">    if (has$1(result, key)) result[key].push(value); else result[key] &#x3D; [value];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Indexes the object&#39;s values by a criterion, similar to &#96;_.groupBy&#96;, but for</span><br><span class="line">  &#x2F;&#x2F; when you know that your index values will be unique.</span><br><span class="line">  var indexBy &#x3D; group(function(result, value, key) &#123;</span><br><span class="line">    result[key] &#x3D; value;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Counts instances of an object that group by a certain criterion. Pass</span><br><span class="line">  &#x2F;&#x2F; either a string attribute to count by, or a function that returns the</span><br><span class="line">  &#x2F;&#x2F; criterion.</span><br><span class="line">  var countBy &#x3D; group(function(result, value, key) &#123;</span><br><span class="line">    if (has$1(result, key)) result[key]++; else result[key] &#x3D; 1;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Split a collection into two arrays: one whose elements all pass the given</span><br><span class="line">  &#x2F;&#x2F; truth test, and one whose elements all do not pass the truth test.</span><br><span class="line">  var partition &#x3D; group(function(result, value, pass) &#123;</span><br><span class="line">    result[pass ? 0 : 1].push(value);</span><br><span class="line">  &#125;, true);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the number of elements in a collection.</span><br><span class="line">  function size(obj) &#123;</span><br><span class="line">    if (obj &#x3D;&#x3D; null) return 0;</span><br><span class="line">    return isArrayLike(obj) ? obj.length : keys(obj).length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Internal &#96;_.pick&#96; helper function to determine whether &#96;key&#96; is an enumerable</span><br><span class="line">  &#x2F;&#x2F; property name of &#96;obj&#96;.</span><br><span class="line">  function keyInObj(value, key, obj) &#123;</span><br><span class="line">    return key in obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a copy of the object only containing the allowed properties.</span><br><span class="line">  var pick &#x3D; restArguments(function(obj, keys) &#123;</span><br><span class="line">    var result &#x3D; &#123;&#125;, iteratee &#x3D; keys[0];</span><br><span class="line">    if (obj &#x3D;&#x3D; null) return result;</span><br><span class="line">    if (isFunction$1(iteratee)) &#123;</span><br><span class="line">      if (keys.length &gt; 1) iteratee &#x3D; optimizeCb(iteratee, keys[1]);</span><br><span class="line">      keys &#x3D; allKeys(obj);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      iteratee &#x3D; keyInObj;</span><br><span class="line">      keys &#x3D; flatten$1(keys, false, false);</span><br><span class="line">      obj &#x3D; Object(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      var key &#x3D; keys[i];</span><br><span class="line">      var value &#x3D; obj[key];</span><br><span class="line">      if (iteratee(value, key, obj)) result[key] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a copy of the object without the disallowed properties.</span><br><span class="line">  var omit &#x3D; restArguments(function(obj, keys) &#123;</span><br><span class="line">    var iteratee &#x3D; keys[0], context;</span><br><span class="line">    if (isFunction$1(iteratee)) &#123;</span><br><span class="line">      iteratee &#x3D; negate(iteratee);</span><br><span class="line">      if (keys.length &gt; 1) context &#x3D; keys[1];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      keys &#x3D; map(flatten$1(keys, false, false), String);</span><br><span class="line">      iteratee &#x3D; function(value, key) &#123;</span><br><span class="line">        return !contains(keys, key);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return pick(obj, iteratee, context);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns everything but the last entry of the array. Especially useful on</span><br><span class="line">  &#x2F;&#x2F; the arguments object. Passing **n** will return all the values in</span><br><span class="line">  &#x2F;&#x2F; the array, excluding the last N.</span><br><span class="line">  function initial(array, n, guard) &#123;</span><br><span class="line">    return slice.call(array, 0, Math.max(0, array.length - (n &#x3D;&#x3D; null || guard ? 1 : n)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Get the first element of an array. Passing **n** will return the first N</span><br><span class="line">  &#x2F;&#x2F; values in the array. The **guard** check allows it to work with &#96;_.map&#96;.</span><br><span class="line">  function first(array, n, guard) &#123;</span><br><span class="line">    if (array &#x3D;&#x3D; null || array.length &lt; 1) return n &#x3D;&#x3D; null || guard ? void 0 : [];</span><br><span class="line">    if (n &#x3D;&#x3D; null || guard) return array[0];</span><br><span class="line">    return initial(array, array.length - n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Returns everything but the first entry of the &#96;array&#96;. Especially useful on</span><br><span class="line">  &#x2F;&#x2F; the &#96;arguments&#96; object. Passing an **n** will return the rest N values in the</span><br><span class="line">  &#x2F;&#x2F; &#96;array&#96;.</span><br><span class="line">  function rest(array, n, guard) &#123;</span><br><span class="line">    return slice.call(array, n &#x3D;&#x3D; null || guard ? 1 : n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Get the last element of an array. Passing **n** will return the last N</span><br><span class="line">  &#x2F;&#x2F; values in the array.</span><br><span class="line">  function last(array, n, guard) &#123;</span><br><span class="line">    if (array &#x3D;&#x3D; null || array.length &lt; 1) return n &#x3D;&#x3D; null || guard ? void 0 : [];</span><br><span class="line">    if (n &#x3D;&#x3D; null || guard) return array[array.length - 1];</span><br><span class="line">    return rest(array, Math.max(0, array.length - n));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Trim out all falsy values from an array.</span><br><span class="line">  function compact(array) &#123;</span><br><span class="line">    return filter(array, Boolean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Flatten out an array, either recursively (by default), or up to &#96;depth&#96;.</span><br><span class="line">  &#x2F;&#x2F; Passing &#96;true&#96; or &#96;false&#96; as &#96;depth&#96; means &#96;1&#96; or &#96;Infinity&#96;, respectively.</span><br><span class="line">  function flatten(array, depth) &#123;</span><br><span class="line">    return flatten$1(array, depth, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Take the difference between one array and a number of other arrays.</span><br><span class="line">  &#x2F;&#x2F; Only the elements present in just the first array will remain.</span><br><span class="line">  var difference &#x3D; restArguments(function(array, rest) &#123;</span><br><span class="line">    rest &#x3D; flatten$1(rest, true, true);</span><br><span class="line">    return filter(array, function(value)&#123;</span><br><span class="line">      return !contains(rest, value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return a version of the array that does not contain the specified value(s).</span><br><span class="line">  var without &#x3D; restArguments(function(array, otherArrays) &#123;</span><br><span class="line">    return difference(array, otherArrays);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Produce a duplicate-free version of the array. If the array has already</span><br><span class="line">  &#x2F;&#x2F; been sorted, you have the option of using a faster algorithm.</span><br><span class="line">  &#x2F;&#x2F; The faster algorithm will not work with an iteratee if the iteratee</span><br><span class="line">  &#x2F;&#x2F; is not a one-to-one function, so providing an iteratee will disable</span><br><span class="line">  &#x2F;&#x2F; the faster algorithm.</span><br><span class="line">  function uniq(array, isSorted, iteratee, context) &#123;</span><br><span class="line">    if (!isBoolean(isSorted)) &#123;</span><br><span class="line">      context &#x3D; iteratee;</span><br><span class="line">      iteratee &#x3D; isSorted;</span><br><span class="line">      isSorted &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (iteratee !&#x3D; null) iteratee &#x3D; cb(iteratee, context);</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    var seen &#x3D; [];</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; getLength(array); i &lt; length; i++) &#123;</span><br><span class="line">      var value &#x3D; array[i],</span><br><span class="line">          computed &#x3D; iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">      if (isSorted &amp;&amp; !iteratee) &#123;</span><br><span class="line">        if (!i || seen !&#x3D;&#x3D; computed) result.push(value);</span><br><span class="line">        seen &#x3D; computed;</span><br><span class="line">      &#125; else if (iteratee) &#123;</span><br><span class="line">        if (!contains(seen, computed)) &#123;</span><br><span class="line">          seen.push(computed);</span><br><span class="line">          result.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (!contains(result, value)) &#123;</span><br><span class="line">        result.push(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Produce an array that contains the union: each distinct element from all of</span><br><span class="line">  &#x2F;&#x2F; the passed-in arrays.</span><br><span class="line">  var union &#x3D; restArguments(function(arrays) &#123;</span><br><span class="line">    return uniq(flatten$1(arrays, true, true));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Produce an array that contains every item shared between all the</span><br><span class="line">  &#x2F;&#x2F; passed-in arrays.</span><br><span class="line">  function intersection(array) &#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    var argsLength &#x3D; arguments.length;</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; getLength(array); i &lt; length; i++) &#123;</span><br><span class="line">      var item &#x3D; array[i];</span><br><span class="line">      if (contains(result, item)) continue;</span><br><span class="line">      var j;</span><br><span class="line">      for (j &#x3D; 1; j &lt; argsLength; j++) &#123;</span><br><span class="line">        if (!contains(arguments[j], item)) break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (j &#x3D;&#x3D;&#x3D; argsLength) result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Complement of zip. Unzip accepts an array of arrays and groups</span><br><span class="line">  &#x2F;&#x2F; each array&#39;s elements on shared indices.</span><br><span class="line">  function unzip(array) &#123;</span><br><span class="line">    var length &#x3D; array &amp;&amp; max(array, getLength).length || 0;</span><br><span class="line">    var result &#x3D; Array(length);</span><br><span class="line"></span><br><span class="line">    for (var index &#x3D; 0; index &lt; length; index++) &#123;</span><br><span class="line">      result[index] &#x3D; pluck(array, index);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Zip together multiple lists into a single array -- elements that share</span><br><span class="line">  &#x2F;&#x2F; an index go together.</span><br><span class="line">  var zip &#x3D; restArguments(unzip);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Converts lists into objects. Pass either a single array of &#96;[key, value]&#96;</span><br><span class="line">  &#x2F;&#x2F; pairs, or two parallel arrays of the same length -- one of keys, and one of</span><br><span class="line">  &#x2F;&#x2F; the corresponding values. Passing by pairs is the reverse of &#96;_.pairs&#96;.</span><br><span class="line">  function object(list, values) &#123;</span><br><span class="line">    var result &#x3D; &#123;&#125;;</span><br><span class="line">    for (var i &#x3D; 0, length &#x3D; getLength(list); i &lt; length; i++) &#123;</span><br><span class="line">      if (values) &#123;</span><br><span class="line">        result[list[i]] &#x3D; values[i];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        result[list[i][0]] &#x3D; list[i][1];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Generate an integer Array containing an arithmetic progression. A port of</span><br><span class="line">  &#x2F;&#x2F; the native Python &#96;range()&#96; function. See</span><br><span class="line">  &#x2F;&#x2F; [the Python documentation](https:&#x2F;&#x2F;docs.python.org&#x2F;library&#x2F;functions.html#range).</span><br><span class="line">  function range(start, stop, step) &#123;</span><br><span class="line">    if (stop &#x3D;&#x3D; null) &#123;</span><br><span class="line">      stop &#x3D; start || 0;</span><br><span class="line">      start &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!step) &#123;</span><br><span class="line">      step &#x3D; stop &lt; start ? -1 : 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var length &#x3D; Math.max(Math.ceil((stop - start) &#x2F; step), 0);</span><br><span class="line">    var range &#x3D; Array(length);</span><br><span class="line"></span><br><span class="line">    for (var idx &#x3D; 0; idx &lt; length; idx++, start +&#x3D; step) &#123;</span><br><span class="line">      range[idx] &#x3D; start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return range;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Chunk a single array into multiple arrays, each containing &#96;count&#96; or fewer</span><br><span class="line">  &#x2F;&#x2F; items.</span><br><span class="line">  function chunk(array, count) &#123;</span><br><span class="line">    if (count &#x3D;&#x3D; null || count &lt; 1) return [];</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    var i &#x3D; 0, length &#x3D; array.length;</span><br><span class="line">    while (i &lt; length) &#123;</span><br><span class="line">      result.push(slice.call(array, i, i +&#x3D; count));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Helper function to continue chaining intermediate results.</span><br><span class="line">  function chainResult(instance, obj) &#123;</span><br><span class="line">    return instance._chain ? _$1(obj).chain() : obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add your own custom functions to the Underscore object.</span><br><span class="line">  function mixin(obj) &#123;</span><br><span class="line">    each(functions(obj), function(name) &#123;</span><br><span class="line">      var func &#x3D; _$1[name] &#x3D; obj[name];</span><br><span class="line">      _$1.prototype[name] &#x3D; function() &#123;</span><br><span class="line">        var args &#x3D; [this._wrapped];</span><br><span class="line">        push.apply(args, arguments);</span><br><span class="line">        return chainResult(this, func.apply(_$1, args));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return _$1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add all mutator &#96;Array&#96; functions to the wrapper.</span><br><span class="line">  each([&#39;pop&#39;, &#39;push&#39;, &#39;reverse&#39;, &#39;shift&#39;, &#39;sort&#39;, &#39;splice&#39;, &#39;unshift&#39;], function(name) &#123;</span><br><span class="line">    var method &#x3D; ArrayProto[name];</span><br><span class="line">    _$1.prototype[name] &#x3D; function() &#123;</span><br><span class="line">      var obj &#x3D; this._wrapped;</span><br><span class="line">      if (obj !&#x3D; null) &#123;</span><br><span class="line">        method.apply(obj, arguments);</span><br><span class="line">        if ((name &#x3D;&#x3D;&#x3D; &#39;shift&#39; || name &#x3D;&#x3D;&#x3D; &#39;splice&#39;) &amp;&amp; obj.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">          delete obj[0];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return chainResult(this, obj);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add all accessor &#96;Array&#96; functions to the wrapper.</span><br><span class="line">  each([&#39;concat&#39;, &#39;join&#39;, &#39;slice&#39;], function(name) &#123;</span><br><span class="line">    var method &#x3D; ArrayProto[name];</span><br><span class="line">    _$1.prototype[name] &#x3D; function() &#123;</span><br><span class="line">      var obj &#x3D; this._wrapped;</span><br><span class="line">      if (obj !&#x3D; null) obj &#x3D; method.apply(obj, arguments);</span><br><span class="line">      return chainResult(this, obj);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Named Exports</span><br><span class="line"></span><br><span class="line">  var allExports &#x3D; &#123;</span><br><span class="line">    __proto__: null,</span><br><span class="line">    VERSION: VERSION,</span><br><span class="line">    restArguments: restArguments,</span><br><span class="line">    isObject: isObject,</span><br><span class="line">    isNull: isNull,</span><br><span class="line">    isUndefined: isUndefined,</span><br><span class="line">    isBoolean: isBoolean,</span><br><span class="line">    isElement: isElement,</span><br><span class="line">    isString: isString,</span><br><span class="line">    isNumber: isNumber,</span><br><span class="line">    isDate: isDate,</span><br><span class="line">    isRegExp: isRegExp,</span><br><span class="line">    isError: isError,</span><br><span class="line">    isSymbol: isSymbol,</span><br><span class="line">    isArrayBuffer: isArrayBuffer,</span><br><span class="line">    isDataView: isDataView$1,</span><br><span class="line">    isArray: isArray,</span><br><span class="line">    isFunction: isFunction$1,</span><br><span class="line">    isArguments: isArguments$1,</span><br><span class="line">    isFinite: isFinite$1,</span><br><span class="line">    isNaN: isNaN$1,</span><br><span class="line">    isTypedArray: isTypedArray$1,</span><br><span class="line">    isEmpty: isEmpty,</span><br><span class="line">    isMatch: isMatch,</span><br><span class="line">    isEqual: isEqual,</span><br><span class="line">    isMap: isMap,</span><br><span class="line">    isWeakMap: isWeakMap,</span><br><span class="line">    isSet: isSet,</span><br><span class="line">    isWeakSet: isWeakSet,</span><br><span class="line">    keys: keys,</span><br><span class="line">    allKeys: allKeys,</span><br><span class="line">    values: values,</span><br><span class="line">    pairs: pairs,</span><br><span class="line">    invert: invert,</span><br><span class="line">    functions: functions,</span><br><span class="line">    methods: functions,</span><br><span class="line">    extend: extend,</span><br><span class="line">    extendOwn: extendOwn,</span><br><span class="line">    assign: extendOwn,</span><br><span class="line">    defaults: defaults,</span><br><span class="line">    create: create,</span><br><span class="line">    clone: clone,</span><br><span class="line">    tap: tap,</span><br><span class="line">    get: get,</span><br><span class="line">    has: has,</span><br><span class="line">    mapObject: mapObject,</span><br><span class="line">    identity: identity,</span><br><span class="line">    constant: constant,</span><br><span class="line">    noop: noop,</span><br><span class="line">    toPath: toPath$1,</span><br><span class="line">    property: property,</span><br><span class="line">    propertyOf: propertyOf,</span><br><span class="line">    matcher: matcher,</span><br><span class="line">    matches: matcher,</span><br><span class="line">    times: times,</span><br><span class="line">    random: random,</span><br><span class="line">    now: now,</span><br><span class="line">    escape: _escape,</span><br><span class="line">    unescape: _unescape,</span><br><span class="line">    templateSettings: templateSettings,</span><br><span class="line">    template: template,</span><br><span class="line">    result: result,</span><br><span class="line">    uniqueId: uniqueId,</span><br><span class="line">    chain: chain,</span><br><span class="line">    iteratee: iteratee,</span><br><span class="line">    partial: partial,</span><br><span class="line">    bind: bind,</span><br><span class="line">    bindAll: bindAll,</span><br><span class="line">    memoize: memoize,</span><br><span class="line">    delay: delay,</span><br><span class="line">    defer: defer,</span><br><span class="line">    throttle: throttle,</span><br><span class="line">    debounce: debounce,</span><br><span class="line">    wrap: wrap,</span><br><span class="line">    negate: negate,</span><br><span class="line">    compose: compose,</span><br><span class="line">    after: after,</span><br><span class="line">    before: before,</span><br><span class="line">    once: once,</span><br><span class="line">    findKey: findKey,</span><br><span class="line">    findIndex: findIndex,</span><br><span class="line">    findLastIndex: findLastIndex,</span><br><span class="line">    sortedIndex: sortedIndex,</span><br><span class="line">    indexOf: indexOf,</span><br><span class="line">    lastIndexOf: lastIndexOf,</span><br><span class="line">    find: find,</span><br><span class="line">    detect: find,</span><br><span class="line">    findWhere: findWhere,</span><br><span class="line">    each: each,</span><br><span class="line">    forEach: each,</span><br><span class="line">    map: map,</span><br><span class="line">    collect: map,</span><br><span class="line">    reduce: reduce,</span><br><span class="line">    foldl: reduce,</span><br><span class="line">    inject: reduce,</span><br><span class="line">    reduceRight: reduceRight,</span><br><span class="line">    foldr: reduceRight,</span><br><span class="line">    filter: filter,</span><br><span class="line">    select: filter,</span><br><span class="line">    reject: reject,</span><br><span class="line">    every: every,</span><br><span class="line">    all: every,</span><br><span class="line">    some: some,</span><br><span class="line">    any: some,</span><br><span class="line">    contains: contains,</span><br><span class="line">    includes: contains,</span><br><span class="line">    include: contains,</span><br><span class="line">    invoke: invoke,</span><br><span class="line">    pluck: pluck,</span><br><span class="line">    where: where,</span><br><span class="line">    max: max,</span><br><span class="line">    min: min,</span><br><span class="line">    shuffle: shuffle,</span><br><span class="line">    sample: sample,</span><br><span class="line">    sortBy: sortBy,</span><br><span class="line">    groupBy: groupBy,</span><br><span class="line">    indexBy: indexBy,</span><br><span class="line">    countBy: countBy,</span><br><span class="line">    partition: partition,</span><br><span class="line">    toArray: toArray,</span><br><span class="line">    size: size,</span><br><span class="line">    pick: pick,</span><br><span class="line">    omit: omit,</span><br><span class="line">    first: first,</span><br><span class="line">    head: first,</span><br><span class="line">    take: first,</span><br><span class="line">    initial: initial,</span><br><span class="line">    last: last,</span><br><span class="line">    rest: rest,</span><br><span class="line">    tail: rest,</span><br><span class="line">    drop: rest,</span><br><span class="line">    compact: compact,</span><br><span class="line">    flatten: flatten,</span><br><span class="line">    without: without,</span><br><span class="line">    uniq: uniq,</span><br><span class="line">    unique: uniq,</span><br><span class="line">    union: union,</span><br><span class="line">    intersection: intersection,</span><br><span class="line">    difference: difference,</span><br><span class="line">    unzip: unzip,</span><br><span class="line">    transpose: unzip,</span><br><span class="line">    zip: zip,</span><br><span class="line">    object: object,</span><br><span class="line">    range: range,</span><br><span class="line">    chunk: chunk,</span><br><span class="line">    mixin: mixin,</span><br><span class="line">    &#39;default&#39;: _$1</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Default Export</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Add all of the Underscore functions to the wrapper object.</span><br><span class="line">  var _ &#x3D; mixin(allExports);</span><br><span class="line">  &#x2F;&#x2F; Legacy Node.js API.</span><br><span class="line">  _._ &#x3D; _;</span><br><span class="line"></span><br><span class="line">  return _;</span><br><span class="line"></span><br><span class="line">&#125;)));</span><br><span class="line">&#x2F;&#x2F;# sourceMappingURL&#x3D;underscore-umd.js.map</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>修订服务器默认端口22</title>
    <url>/Linux/linux-1.html</url>
    <content><![CDATA[<h1 id="查看ssh端口"><a href="#查看ssh端口" class="headerlink" title="查看ssh端口"></a>查看ssh端口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp|grep ssh</span><br></pre></td></tr></table></figure>

<h1 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure>
<p>看到#Port 22 ,可以再加一行<br>Port xxxx端口（10000~65535区间）</p>
<h1 id="重启ssh"><a href="#重启ssh" class="headerlink" title="重启ssh"></a>重启ssh</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<h1 id="查看监听的端口"><a href="#查看监听的端口" class="headerlink" title="查看监听的端口"></a>查看监听的端口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netstat -tunlp | grep &quot;ssh&quot;</span><br></pre></td></tr></table></figure>

<h1 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@localhost -p xxxx端口</span><br></pre></td></tr></table></figure>
<p>中途会让你输入你的密码</p>
<h1 id="继续第二步骤删除port-22"><a href="#继续第二步骤删除port-22" class="headerlink" title="继续第二步骤删除port 22"></a>继续第二步骤删除port 22</h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云Docker+Nginx部署同端口多个Vue前端项目</title>
    <url>/Docker/nginx-2.html</url>
    <content><![CDATA[<h1 id="Vue打包"><a href="#Vue打包" class="headerlink" title="Vue打包"></a>Vue打包</h1><blockquote>
<p><code>Vue.config.js</code>新增  <code>publicPath: &quot;./&quot;</code>或者写死也行，<a href="https://cli.vuejs.org/zh/config/#publicpath]">vue-cl</a>关于publishPath的解释</p>
</blockquote>
<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><p>删除<code>conf.d</code>中的<code>default.conf</code>分别建立不同的项目配置。比如这里叫<code>demo1和demo2</code>，新建两个文件<code>demo1.conf和demo2.conf</code><br>并且配置中更改<code>location</code><br><code>demo1.conf</code> 中 <code>root   /usr/share/nginx/html;改为 /usr/share/nginx/html/demo1</code><br><code>demo2.conf</code> 中 <code>root   /usr/share/nginx/html;改为 /usr/share/nginx/html/demo2</code></p>
<p>然后在主机目录<code>html</code>中新建<code>demo1</code>和<code>demo2</code>文件夹。并分别上传项目即可</p>
]]></content>
      <categories>
        <category>AliYun</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>nginx</tag>
        <tag>前端部署</tag>
      </tags>
  </entry>
  <entry>
    <title>layout</title>
    <url>/Angular/angular-1-1.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>阿里云Docker+Nginx部署项目</title>
    <url>/Docker/nginx.html</url>
    <content><![CDATA[<p>购买的阿里云服务器已经安装了的<code>Docker</code>.所以这里只装nginx镜像即可即可</p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<p>查询已安装镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/Docker/nginx/1.png" alt="查询镜像"></p>
<h2 id="启动nginx容器测试"><a href="#启动nginx容器测试" class="headerlink" title="启动nginx容器测试"></a>启动nginx容器测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name test-nginx -p 8080:80 -d nignx</span><br></pre></td></tr></table></figure>
<p><code>name</code> 容器名称。<br><code>p</code> <code>8080</code>端口映射到80 （<font color="red">注意在阿里云安全中要添加8080端口的规则</font>）</p>
<p><img src="/Docker/nginx/2.png" alt="启动"></p>
<h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>将主机目录挂载到nginx容器中</p>
<h3 id="新建需要挂载的目录"><a href="#新建需要挂载的目录" class="headerlink" title="新建需要挂载的目录"></a>新建需要挂载的目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;welink&#x2F;nginx&#x2F;html &#x2F;welink&#x2F;nginx&#x2F;logs &#x2F;welink&#x2F;nginx&#x2F;conf &#x2F;welink&#x2F;nginx&#x2F;conf.d</span><br></pre></td></tr></table></figure>

<p><code>html</code>目录用于存放静态资源文件（web站点资源等）<br><code>logs</code>存放日志<br><code>conf</code>存放配置文件<br><code>conf.d</code> 存放多域名的配置文件</p>
<p>其中<code>conf</code>和<code>conf.d</code>的关系：<br>是需要我们把配置文件拆分开来,在<code>/etc/nginx/conf.d/</code> 文件建立对应的域名配置文件,比如 <code>/etc/nginx/conf.d/123.com.conf</code><br>只需要在原来文件<code>/etc/nginx/nginx.conf 的http</code> 块下加一句话就可以了:<br><code>include /etc/nginx/conf.d/*.conf</code>;</p>
<h3 id="复制默认文件到主机目录中"><a href="#复制默认文件到主机目录中" class="headerlink" title="复制默认文件到主机目录中"></a>复制默认文件到主机目录中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp test-nginx:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;welink&#x2F;nginx&#x2F;conf</span><br><span class="line">docker cp test-nginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf &#x2F;welink&#x2F;nginx&#x2F;conf.d</span><br></pre></td></tr></table></figure>
<h3 id="查询容器"><a href="#查询容器" class="headerlink" title="查询容器"></a>查询容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><img src="/Docker/nginx/3.png" alt="查询启动容器"></p>
<h3 id="停止并删除容器"><a href="#停止并删除容器" class="headerlink" title="停止并删除容器"></a>停止并删除容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop test-nginx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm -f 0abbf56d882a</span><br></pre></td></tr></table></figure>
<h3 id="运行并将主机目录挂载到容器镜像目录中"><a href="#运行并将主机目录挂载到容器镜像目录中" class="headerlink" title="运行并将主机目录挂载到容器镜像目录中"></a>运行并将主机目录挂载到容器镜像目录中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8080:80 \</span><br><span class="line">--name test-nginx \</span><br><span class="line">-v &#x2F;welink&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;welink&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v &#x2F;welink&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v &#x2F;welink&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<h2 id="修改html并预览"><a href="#修改html并预览" class="headerlink" title="修改html并预览"></a>修改html并预览</h2><p>这里直接用宝塔面板新建一个<code>html</code>文件<br><img src="/Docker/nginx/4.png" alt="查询启动容器"><br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World Nginx&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><br>效果：<br><img src="/Docker/nginx/5.png" alt="查询启动容器"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>安装<code>nginx</code></li>
<li>新建主机目录</li>
<li>复制默认文件到主机目录中</li>
<li>挂载主机目录到容器镜像中</li>
<li>具体<code>nginx</code>配置可视情况自己修改</li>
</ol>
]]></content>
      <categories>
        <category>AliYun</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>nginx</tag>
        <tag>前端部署</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/React/React-1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title>Node</title>
    <url>/Node/Node-1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/Vue/vue-1.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>hexo相关</title>
    <url>/hexo/hexo-1.html</url>
    <content><![CDATA[<h1 id="本地运行预览"><a href="#本地运行预览" class="headerlink" title="本地运行预览"></a>本地运行预览</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure>

<h1 id="执行部署前置"><a href="#执行部署前置" class="headerlink" title="执行部署前置"></a>执行部署前置</h1><p>部署之间最好使用github sshkey来建立连接</p>
<h1 id="加入资源文件"><a href="#加入资源文件" class="headerlink" title="加入资源文件"></a>加入资源文件</h1><blockquote>
<p>想加入少量静态资源图片等文件</p>
</blockquote>
<p>根目录的<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder:true</span><br></pre></td></tr></table></figure>
<p>而资源最好放在同级的规划好的目录中，如下方式的同级目录</p>
<h1 id="建立文档目录结构"><a href="#建立文档目录结构" class="headerlink" title="建立文档目录结构"></a>建立文档目录结构</h1><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new layout -p name&#x2F;name1</span><br></pre></td></tr></table></figure>
<p>来建立相应的区块目录。相关文档放在一起<br>如：分别建立Angular、React、Vue、Node 区块</p>
<p>分别执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new layout -p Angular&#x2F;angular-1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new layout -p Angular&#x2F;angular-2</span><br></pre></td></tr></table></figure>
<p>…..</p>
<a id="more"></a>

<p>生成目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source\_posts</span><br><span class="line">├── Angular</span><br><span class="line">|  ├── angular-1 &#x2F;&#x2F; 用于angular-1引用的。放置静态资源文件的文件夹·（anguarl-1&#x2F;xxx.png）</span><br><span class="line">|  └── angular-2 &#x2F;&#x2F; 用于angular-2引用的。放置静态资源文件的文件夹·</span><br><span class="line">|  ├── angular-1.md</span><br><span class="line">|  └── angular-2.md</span><br><span class="line">├── Node</span><br><span class="line">|  ├── Node-1 &#x2F;&#x2F; 放置静态资源文件的文件夹·</span><br><span class="line">|  └── Node-1.md</span><br><span class="line">├── test</span><br><span class="line">|  ├── test1 &#x2F;&#x2F; 放置静态资源文件的文件夹·</span><br><span class="line">|  └── test1.md</span><br><span class="line">└── Vue</span><br><span class="line">   ├── vue-1 &#x2F;&#x2F; 放置静态资源文件的文件夹·</span><br><span class="line">   └── vue-1.md</span><br></pre></td></tr></table></figure>

<h1 id="运行报错TypeError-ERR-INVALID-ARG-TYPE"><a href="#运行报错TypeError-ERR-INVALID-ARG-TYPE" class="headerlink" title="运行报错TypeError [ERR_INVALID_ARG_TYPE]"></a>运行报错TypeError [ERR_INVALID_ARG_TYPE]</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object</span><br><span class="line">    at copyFile (fs.js:1972:10)</span><br></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote>
<p>hexo 和 node 版本不匹配。这里使用nvm 进行降低版本。即可</p>
</blockquote>
<h1 id="执行部署报错fatal-unable-to-auto-detect-email-address"><a href="#执行部署报错fatal-unable-to-auto-detect-email-address" class="headerlink" title="执行部署报错fatal: unable to auto-detect email address"></a>执行部署报错fatal: unable to auto-detect email address</h1><p>对.deploy_git/git中的config文件添加：<br>[user]<br>    email = 邮箱<br>    name = 用户名</p>
<h1 id="运行部署"><a href="#运行部署" class="headerlink" title="运行部署"></a>运行部署</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>github pages hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端运行</title>
    <url>/doc.html</url>
    <content><![CDATA[<h1 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h1><h2 id="方式一-："><a href="#方式一-：" class="headerlink" title="方式一 ："></a>方式一 ：</h2><blockquote>
<p>直接安装node</p>
</blockquote>
<p>  访问地址：<a href="https://nodejs.org/zh-cn/download/releases/">node版本下载地址</a><br>  这里以<code>14.5.4</code>版本为例（尽量高于<code>14.5.4</code>，本项目node-sass基于的node或高于<code>14.5.4</code>）</p>
<a id="more"></a>

<p>  选择<code>14.5.4</code>版本点击下载<br>  <img src="/doc/2.png" alt="下载node"><br>  选择你系统对应的<code>64</code>位或者<code>32</code>位的<code>node</code><br>  <img src="/doc/1.png" alt="下载node"></p>
<h2 id="方式二-："><a href="#方式二-：" class="headerlink" title="方式二 ："></a>方式二 ：</h2><blockquote>
<p>使用node管理工具安装（<font color="red"> 推荐 </font>）<br>   <strong>Unix / OS X</strong>:<br>安装：<a href="https://nodejs.org/zh-cn/download/package-manager/#nvm">https://nodejs.org/zh-cn/download/package-manager/#nvm</a></p>
</blockquote>
<p>   <strong>Windows</strong><br>    安装<a href="https://github.com/coreybutler/nvm-windows">nvm</a><br>    1.点击<a href="https://github.com/coreybutler/nvm-windows/releases">releases</a>进行安装<br>    2.选择最新的版本进行下载安装(<br>    <img src="/doc/3.png" alt="nvm"><br>    3.下载完成安装过程中。若出现以下提示，选择是让<code>nvm</code>管理原安装过的<code>node</code><br>    <img src="/doc/4.png" alt="nvm"><br>    4.安装之后常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls &#x2F;&#x2F; 查看目前已经安装的版本</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install 14.15.4  &#x2F;&#x2F; 安装指定的版本的nodejs</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use 14.15.4  &#x2F;&#x2F; 使用指定版本的nodejs</span><br></pre></td></tr></table></figure>
<h1 id="nrm安装"><a href="#nrm安装" class="headerlink" title="nrm安装"></a>nrm安装</h1><blockquote>
<p>管理不同镜像源</p>
</blockquote>
<p>对于国内环境。有时在下载依赖时，会出现安装失败的情况，而有时有需要访问其他源，如<code>npm</code>本身源，进行提交<code>npm</code>包等。</p>
<p>1.安装<code>nrm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure>
<p>2.常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nrm ls &#x2F;&#x2F; 查看所有的镜像源列表</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use taobao  &#x2F;&#x2F; 切换为淘宝镜像</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm use taobao  &#x2F;&#x2F; 测试镜像速度</span><br></pre></td></tr></table></figure>
<p><img src="/doc/5.png" alt="nvm"></p>
<h1 id="vue-cli安装-非必须"><a href="#vue-cli安装-非必须" class="headerlink" title="vue-cli安装 (非必须)"></a>vue-cli安装 (非必须)</h1><blockquote>
<p>当你需要cli新建项目等，才进行安装。一般运行不需要安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>

<h1 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h1><blockquote>
<p><code>vscode</code> 安装之后， 安装项目所需插件。<br>   1.<strong>Veture</strong>、<br>   2.<strong>Prettier - Code formatter</strong>、<br>   3.<strong>Eslint</strong></p>
</blockquote>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── babel.config.js  &#x2F;&#x2F; Babel转码器配置文件</span><br><span class="line">├── jsconfig.json  &#x2F;&#x2F; 你的文件所在目录下的所有js代码做出个性化支持</span><br><span class="line">├── mock  &#x2F;&#x2F; 模拟数据</span><br><span class="line">├── package-lock.json  &#x2F;&#x2F; 锁定依赖版本</span><br><span class="line">├── package.json &#x2F;&#x2F; 项目或者各种依赖包的描述等</span><br><span class="line">├── plopfile.js  &#x2F;&#x2F;模块plop入口文件</span><br><span class="line">├── postcss.config.js &#x2F;&#x2F; postcss处理css 平台配置文件</span><br><span class="line">├── public  &#x2F;&#x2F; index页面</span><br><span class="line">├── README.md &#x2F;&#x2F; 说明md文件</span><br><span class="line">├── src  </span><br><span class="line">|  ├── App.vue  &#x2F;&#x2F; vue 根几点App</span><br><span class="line">|  ├── assets &#x2F;&#x2F; 静态资源文件夹</span><br><span class="line">|  ├── common &#x2F;&#x2F; 公用变量以及系统配置文件</span><br><span class="line">|  |  ├── api.js</span><br><span class="line">|  |  ├── btn.js</span><br><span class="line">|  |  ├── constants.js</span><br><span class="line">|  |  └── settings.js</span><br><span class="line">|  ├── components &#x2F;&#x2F; 组件</span><br><span class="line">|  ├── directive &#x2F;&#x2F; 指令</span><br><span class="line">|  ├── filters &#x2F;&#x2F; 过滤器</span><br><span class="line">|  ├── icons &#x2F;&#x2F; svg </span><br><span class="line">|  ├── layout &#x2F;&#x2F; 系统布局文件</span><br><span class="line">|  ├── main.js &#x2F;&#x2F; 系统入口</span><br><span class="line">|  ├── mixins &#x2F;&#x2F; 代码复用</span><br><span class="line">|  ├── permission.js &#x2F;&#x2F; 权限路由控制等</span><br><span class="line">|  ├── router &#x2F;&#x2F; 路由文件</span><br><span class="line">|  ├── store &#x2F;&#x2F; 状态管理</span><br><span class="line">|  ├── styles &#x2F;&#x2F; 系统样式</span><br><span class="line">|  ├── utils &#x2F;&#x2F; 公用方法</span><br><span class="line">|  └── views &#x2F;&#x2F; 业务逻辑（*）</span><br><span class="line">└── vue.config.js &#x2F;&#x2F; vue 细化配置文件</span><br></pre></td></tr></table></figure>
<h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><h2 id="修改-env-dev"><a href="#修改-env-dev" class="headerlink" title="修改.env.dev"></a>修改.env.dev</h2><p>  修改<code>VUE_APP_BASE_TARGET_API</code> 为你需要联调的后端地址</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install  &#x2F;&#x2F; 安装依赖（后面安装之后即不需要）</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>welink文档</category>
      </categories>
  </entry>
  <entry>
    <title>eslint 规则</title>
    <url>/eslint.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;no-alert&quot;: 0,&#x2F;&#x2F;禁止使用alert confirm prompt</span><br><span class="line">&quot;no-array-constructor&quot;: 2,&#x2F;&#x2F;禁止使用数组构造器</span><br><span class="line">&quot;no-bitwise&quot;: 0,&#x2F;&#x2F;禁止使用按位运算符</span><br><span class="line">&quot;no-caller&quot;: 1,&#x2F;&#x2F;禁止使用arguments.caller或arguments.callee</span><br><span class="line">&quot;no-catch-shadow&quot;: 2,&#x2F;&#x2F;禁止catch子句参数与外部作用域变量同名</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;no-class-assign&quot;: 2,&#x2F;&#x2F;禁止给类赋值</span><br><span class="line">&quot;no-cond-assign&quot;: 2,&#x2F;&#x2F;禁止在条件表达式中使用赋值语句</span><br><span class="line">&quot;no-console&quot;: 2,&#x2F;&#x2F;禁止使用console</span><br><span class="line">&quot;no-const-assign&quot;: 2,&#x2F;&#x2F;禁止修改const声明的变量</span><br><span class="line">&quot;no-constant-condition&quot;: 2,&#x2F;&#x2F;禁止在条件中使用常量表达式 if(true) if(1)</span><br><span class="line">&quot;no-continue&quot;: 0,&#x2F;&#x2F;禁止使用continue</span><br><span class="line">&quot;no-control-regex&quot;: 2,&#x2F;&#x2F;禁止在正则表达式中使用控制字符</span><br><span class="line">&quot;no-debugger&quot;: 2,&#x2F;&#x2F;禁止使用debugger</span><br><span class="line">&quot;no-delete-var&quot;: 2,&#x2F;&#x2F;不能对var声明的变量使用delete操作符</span><br><span class="line">&quot;no-div-regex&quot;: 1,&#x2F;&#x2F;不能使用看起来像除法的正则表达式&#x2F;&#x3D;foo&#x2F;</span><br><span class="line">&quot;no-dupe-keys&quot;: 2,&#x2F;&#x2F;在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span><br><span class="line">&quot;no-dupe-args&quot;: 2,&#x2F;&#x2F;函数参数不能重复</span><br><span class="line">&quot;no-duplicate-case&quot;: 2,&#x2F;&#x2F;switch中的case标签不能重复</span><br><span class="line">&quot;no-else-return&quot;: 2,&#x2F;&#x2F;如果if语句里面有return,后面不能跟else语句</span><br><span class="line">&quot;no-empty&quot;: 2,&#x2F;&#x2F;块语句中的内容不能为空</span><br><span class="line">&quot;no-empty-character-class&quot;: 2,&#x2F;&#x2F;正则表达式中的[]内容不能为空</span><br><span class="line">&quot;no-empty-label&quot;: 2,&#x2F;&#x2F;禁止使用空label</span><br><span class="line">&quot;no-eq-null&quot;: 2,&#x2F;&#x2F;禁止对null使用&#x3D;&#x3D;或!&#x3D;运算符</span><br><span class="line">&quot;no-eval&quot;: 1,&#x2F;&#x2F;禁止使用eval</span><br><span class="line">&quot;no-ex-assign&quot;: 2,&#x2F;&#x2F;禁止给catch语句中的异常参数赋值</span><br><span class="line">&quot;no-extend-native&quot;: 2,&#x2F;&#x2F;禁止扩展native对象</span><br><span class="line">&quot;no-extra-bind&quot;: 2,&#x2F;&#x2F;禁止不必要的函数绑定</span><br><span class="line">&quot;no-extra-boolean-cast&quot;: 2,&#x2F;&#x2F;禁止不必要的bool转换</span><br><span class="line">&quot;no-extra-parens&quot;: 2,&#x2F;&#x2F;禁止非必要的括号</span><br><span class="line">&quot;no-extra-semi&quot;: 2,&#x2F;&#x2F;禁止多余的冒号</span><br><span class="line">&quot;no-fallthrough&quot;: 1,&#x2F;&#x2F;禁止switch穿透</span><br><span class="line">&quot;no-floating-decimal&quot;: 2,&#x2F;&#x2F;禁止省略浮点数中的0 .5 3.</span><br><span class="line">&quot;no-func-assign&quot;: 2,&#x2F;&#x2F;禁止重复的函数声明</span><br><span class="line">&quot;no-implicit-coercion&quot;: 1,&#x2F;&#x2F;禁止隐式转换</span><br><span class="line">&quot;no-implied-eval&quot;: 2,&#x2F;&#x2F;禁止使用隐式eval</span><br><span class="line">&quot;no-inline-comments&quot;: 0,&#x2F;&#x2F;禁止行内备注</span><br><span class="line">&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],&#x2F;&#x2F;禁止在块语句中使用声明（变量或函数）</span><br><span class="line">&quot;no-invalid-regexp&quot;: 2,&#x2F;&#x2F;禁止无效的正则表达式</span><br><span class="line">&quot;no-invalid-this&quot;: 2,&#x2F;&#x2F;禁止无效的this，只能用在构造器，类，对象字面量</span><br><span class="line">&quot;no-irregular-whitespace&quot;: 2,&#x2F;&#x2F;不能有不规则的空格</span><br><span class="line">&quot;no-iterator&quot;: 2,&#x2F;&#x2F;禁止使用__iterator__ 属性</span><br><span class="line">&quot;no-label-var&quot;: 2,&#x2F;&#x2F;label名不能与var声明的变量名相同</span><br><span class="line">&quot;no-labels&quot;: 2,&#x2F;&#x2F;禁止标签声明</span><br><span class="line">&quot;no-lone-blocks&quot;: 2,&#x2F;&#x2F;禁止不必要的嵌套块</span><br><span class="line">&quot;no-lonely-if&quot;: 2,&#x2F;&#x2F;禁止else语句内只有if语句</span><br><span class="line">&quot;no-loop-func&quot;: 1,&#x2F;&#x2F;禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span><br><span class="line">&quot;no-mixed-requires&quot;: [0, false],&#x2F;&#x2F;声明时不能混用声明类型</span><br><span class="line">&quot;no-mixed-spaces-and-tabs&quot;: [2, false],&#x2F;&#x2F;禁止混用tab和空格</span><br><span class="line">&quot;linebreak-style&quot;: [0, &quot;windows&quot;],&#x2F;&#x2F;换行风格</span><br><span class="line">&quot;no-multi-spaces&quot;: 1,&#x2F;&#x2F;不能用多余的空格</span><br><span class="line">&quot;no-multi-str&quot;: 2,&#x2F;&#x2F;字符串不能用\换行</span><br><span class="line">&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],&#x2F;&#x2F;空行最多不能超过2行</span><br><span class="line">&quot;no-native-reassign&quot;: 2,&#x2F;&#x2F;不能重写native对象</span><br><span class="line">&quot;no-negated-in-lhs&quot;: 2,&#x2F;&#x2F;in 操作符的左边不能有!</span><br><span class="line">&quot;no-nested-ternary&quot;: 0,&#x2F;&#x2F;禁止使用嵌套的三目运算</span><br><span class="line">&quot;no-new&quot;: 1,&#x2F;&#x2F;禁止在使用new构造一个实例后不赋值</span><br><span class="line">&quot;no-new-func&quot;: 1,&#x2F;&#x2F;禁止使用new Function</span><br><span class="line">&quot;no-new-object&quot;: 2,&#x2F;&#x2F;禁止使用new Object()</span><br><span class="line">&quot;no-new-require&quot;: 2,&#x2F;&#x2F;禁止使用new require</span><br><span class="line">&quot;no-new-wrappers&quot;: 2,&#x2F;&#x2F;禁止使用new创建包装实例，new String new Boolean new Number</span><br><span class="line">&quot;no-obj-calls&quot;: 2,&#x2F;&#x2F;不能调用内置的全局对象，比如Math() JSON()</span><br><span class="line">&quot;no-octal&quot;: 2,&#x2F;&#x2F;禁止使用八进制数字</span><br><span class="line">&quot;no-octal-escape&quot;: 2,&#x2F;&#x2F;禁止使用八进制转义序列</span><br><span class="line">&quot;no-param-reassign&quot;: 2,&#x2F;&#x2F;禁止给参数重新赋值</span><br><span class="line">&quot;no-path-concat&quot;: 0,&#x2F;&#x2F;node中不能使用__dirname或__filename做路径拼接</span><br><span class="line">&quot;no-plusplus&quot;: 0,&#x2F;&#x2F;禁止使用++，--</span><br><span class="line">&quot;no-process-env&quot;: 0,&#x2F;&#x2F;禁止使用process.env</span><br><span class="line">&quot;no-process-exit&quot;: 0,&#x2F;&#x2F;禁止使用process.exit()</span><br><span class="line">&quot;no-proto&quot;: 2,&#x2F;&#x2F;禁止使用__proto__属性</span><br><span class="line">&quot;no-redeclare&quot;: 2,&#x2F;&#x2F;禁止重复声明变量</span><br><span class="line">&quot;no-regex-spaces&quot;: 2,&#x2F;&#x2F;禁止在正则表达式字面量中使用多个空格 &#x2F;foo bar&#x2F;</span><br><span class="line">&quot;no-restricted-modules&quot;: 0,&#x2F;&#x2F;如果禁用了指定模块，使用就会报错</span><br><span class="line">&quot;no-return-assign&quot;: 1,&#x2F;&#x2F;return 语句中不能有赋值表达式</span><br><span class="line">&quot;no-script-url&quot;: 0,&#x2F;&#x2F;禁止使用javascript:void(0)</span><br><span class="line">&quot;no-self-compare&quot;: 2,&#x2F;&#x2F;不能比较自身</span><br><span class="line">&quot;no-sequences&quot;: 0,&#x2F;&#x2F;禁止使用逗号运算符</span><br><span class="line">&quot;no-shadow&quot;: 2,&#x2F;&#x2F;外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span><br><span class="line">&quot;no-shadow-restricted-names&quot;: 2,&#x2F;&#x2F;严格模式中规定的限制标识符不能作为声明时的变量名使用</span><br><span class="line">&quot;no-spaced-func&quot;: 2,&#x2F;&#x2F;函数调用时 函数名与()之间不能有空格</span><br><span class="line">&quot;no-sparse-arrays&quot;: 2,&#x2F;&#x2F;禁止稀疏数组， [1,,2]</span><br><span class="line">&quot;no-sync&quot;: 0,&#x2F;&#x2F;nodejs 禁止同步方法</span><br><span class="line">&quot;no-ternary&quot;: 0,&#x2F;&#x2F;禁止使用三目运算符</span><br><span class="line">&quot;no-trailing-spaces&quot;: 1,&#x2F;&#x2F;一行结束后面不要有空格</span><br><span class="line">&quot;no-this-before-super&quot;: 0,&#x2F;&#x2F;在调用super()之前不能使用this或super</span><br><span class="line">&quot;no-throw-literal&quot;: 2,&#x2F;&#x2F;禁止抛出字面量错误 throw &quot;error&quot;;</span><br><span class="line">&quot;no-undef&quot;: 1,&#x2F;&#x2F;不能有未定义的变量</span><br><span class="line">&quot;no-undef-init&quot;: 2,&#x2F;&#x2F;变量初始化时不能直接给它赋值为undefined</span><br><span class="line">&quot;no-undefined&quot;: 2,&#x2F;&#x2F;不能使用undefined</span><br><span class="line">&quot;no-unexpected-multiline&quot;: 2,&#x2F;&#x2F;避免多行表达式</span><br><span class="line">&quot;no-underscore-dangle&quot;: 1,&#x2F;&#x2F;标识符不能以_开头或结尾</span><br><span class="line">&quot;no-unneeded-ternary&quot;: 2,&#x2F;&#x2F;禁止不必要的嵌套 var isYes &#x3D; answer &#x3D;&#x3D;&#x3D; 1 ? true : false;</span><br><span class="line">&quot;no-unreachable&quot;: 2,&#x2F;&#x2F;不能有无法执行的代码</span><br><span class="line">&quot;no-unused-expressions&quot;: 2,&#x2F;&#x2F;禁止无用的表达式</span><br><span class="line">&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],&#x2F;&#x2F;不能有声明后未被使用的变量或参数</span><br><span class="line">&quot;no-use-before-define&quot;: 2,&#x2F;&#x2F;未定义前不能使用</span><br><span class="line">&quot;no-useless-call&quot;: 2,&#x2F;&#x2F;禁止不必要的call和apply</span><br><span class="line">&quot;no-void&quot;: 2,&#x2F;&#x2F;禁用void操作符</span><br><span class="line">&quot;no-var&quot;: 0,&#x2F;&#x2F;禁用var，用let和const代替</span><br><span class="line">&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],&#x2F;&#x2F;不能有警告备注</span><br><span class="line">&quot;no-with&quot;: 2,&#x2F;&#x2F;禁用with</span><br><span class="line"></span><br><span class="line">&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],&#x2F;&#x2F;是否允许非空数组里面有多余的空格</span><br><span class="line">&quot;arrow-parens&quot;: 0,&#x2F;&#x2F;箭头函数用小括号括起来</span><br><span class="line">&quot;arrow-spacing&quot;: 0,&#x2F;&#x2F;&#x3D;&gt;的前&#x2F;后括号</span><br><span class="line">&quot;accessor-pairs&quot;: 0,&#x2F;&#x2F;在对象中使用getter&#x2F;setter</span><br><span class="line">&quot;block-scoped-var&quot;: 0,&#x2F;&#x2F;块语句中使用var</span><br><span class="line">&quot;brace-style&quot;: [1, &quot;1tbs&quot;],&#x2F;&#x2F;大括号风格</span><br><span class="line">&quot;callback-return&quot;: 1,&#x2F;&#x2F;避免多次调用回调什么的</span><br><span class="line">&quot;camelcase&quot;: 2,&#x2F;&#x2F;强制驼峰法命名</span><br><span class="line">&quot;comma-dangle&quot;: [2, &quot;never&quot;],&#x2F;&#x2F;对象字面量项尾不能有逗号</span><br><span class="line">&quot;comma-spacing&quot;: 0,&#x2F;&#x2F;逗号前后的空格</span><br><span class="line">&quot;comma-style&quot;: [2, &quot;last&quot;],&#x2F;&#x2F;逗号风格，换行时在行首还是行尾</span><br><span class="line">&quot;complexity&quot;: [0, 11],&#x2F;&#x2F;循环复杂度</span><br><span class="line">&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],&#x2F;&#x2F;是否允许计算后的键名什么的</span><br><span class="line">&quot;consistent-return&quot;: 0,&#x2F;&#x2F;return 后面是否允许省略</span><br><span class="line">&quot;consistent-this&quot;: [2, &quot;that&quot;],&#x2F;&#x2F;this别名</span><br><span class="line">&quot;constructor-super&quot;: 0,&#x2F;&#x2F;非派生类不能调用super，派生类必须调用super</span><br><span class="line">&quot;curly&quot;: [2, &quot;all&quot;],&#x2F;&#x2F;必须使用 if()&#123;&#125; 中的&#123;&#125;</span><br><span class="line">&quot;default-case&quot;: 2,&#x2F;&#x2F;switch语句最后必须有default</span><br><span class="line">&quot;dot-location&quot;: 0,&#x2F;&#x2F;对象访问符的位置，换行的时候在行首还是行尾</span><br><span class="line">&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],&#x2F;&#x2F;避免不必要的方括号</span><br><span class="line">&quot;eol-last&quot;: 0,&#x2F;&#x2F;文件以单一的换行符结束</span><br><span class="line">&quot;eqeqeq&quot;: 2,&#x2F;&#x2F;必须使用全等</span><br><span class="line">&quot;func-names&quot;: 0,&#x2F;&#x2F;函数表达式必须有名字</span><br><span class="line">&quot;func-style&quot;: [0, &quot;declaration&quot;],&#x2F;&#x2F;函数风格，规定只能使用函数声明&#x2F;函数表达式</span><br><span class="line">&quot;generator-star-spacing&quot;: 0,&#x2F;&#x2F;生成器函数*的前后空格</span><br><span class="line">&quot;guard-for-in&quot;: 0,&#x2F;&#x2F;for in循环要用if语句过滤</span><br><span class="line">&quot;handle-callback-err&quot;: 0,&#x2F;&#x2F;nodejs 处理错误</span><br><span class="line">&quot;id-length&quot;: 0,&#x2F;&#x2F;变量名长度</span><br><span class="line">&quot;indent&quot;: [2, 4],&#x2F;&#x2F;缩进风格</span><br><span class="line">&quot;init-declarations&quot;: 0,&#x2F;&#x2F;声明时必须赋初值</span><br><span class="line">&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],&#x2F;&#x2F;对象字面量中冒号的前后空格</span><br><span class="line">&quot;lines-around-comment&quot;: 0,&#x2F;&#x2F;行前&#x2F;行后备注</span><br><span class="line">&quot;max-depth&quot;: [0, 4],&#x2F;&#x2F;嵌套块深度</span><br><span class="line">&quot;max-len&quot;: [0, 80, 4],&#x2F;&#x2F;字符串最大长度</span><br><span class="line">&quot;max-nested-callbacks&quot;: [0, 2],&#x2F;&#x2F;回调嵌套深度</span><br><span class="line">&quot;max-params&quot;: [0, 3],&#x2F;&#x2F;函数最多只能有3个参数</span><br><span class="line">&quot;max-statements&quot;: [0, 10],&#x2F;&#x2F;函数内最多有几个声明</span><br><span class="line">&quot;new-cap&quot;: 2,&#x2F;&#x2F;函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span><br><span class="line">&quot;new-parens&quot;: 2,&#x2F;&#x2F;new时必须加小括号</span><br><span class="line">&quot;newline-after-var&quot;: 2,&#x2F;&#x2F;变量声明后是否需要空一行</span><br><span class="line">&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],&#x2F;&#x2F;大括号内是否允许不必要的空格</span><br><span class="line">&quot;object-shorthand&quot;: 0,&#x2F;&#x2F;强制对象字面量缩写语法</span><br><span class="line">&quot;one-var&quot;: 1,&#x2F;&#x2F;连续声明</span><br><span class="line">&quot;operator-assignment&quot;: [0, &quot;always&quot;],&#x2F;&#x2F;赋值运算符 +&#x3D; -&#x3D;什么的</span><br><span class="line">&quot;operator-linebreak&quot;: [2, &quot;after&quot;],&#x2F;&#x2F;换行时运算符在行尾还是行首</span><br><span class="line">&quot;padded-blocks&quot;: 0,&#x2F;&#x2F;块语句内行首行尾是否要空行</span><br><span class="line">&quot;prefer-const&quot;: 0,&#x2F;&#x2F;首选const</span><br><span class="line">&quot;prefer-spread&quot;: 0,&#x2F;&#x2F;首选展开运算</span><br><span class="line">&quot;prefer-reflect&quot;: 0,&#x2F;&#x2F;首选Reflect的方法</span><br><span class="line">&quot;quotes&quot;: [1, &quot;single&quot;],&#x2F;&#x2F;引号类型 &#96;&#96; &quot;&quot; &#39;&#39;</span><br><span class="line">&quot;quote-props&quot;:[2, &quot;always&quot;],&#x2F;&#x2F;对象字面量中的属性名是否强制双引号</span><br><span class="line">&quot;radix&quot;: 2,&#x2F;&#x2F;parseInt必须指定第二个参数</span><br><span class="line">&quot;id-match&quot;: 0,&#x2F;&#x2F;命名检测</span><br><span class="line">&quot;require-yield&quot;: 0,&#x2F;&#x2F;生成器函数必须有yield</span><br><span class="line">&quot;semi&quot;: [2, &quot;always&quot;],&#x2F;&#x2F;语句强制分号结尾</span><br><span class="line">&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],&#x2F;&#x2F;分号前后空格</span><br><span class="line">&quot;sort-vars&quot;: 0,&#x2F;&#x2F;变量声明时排序</span><br><span class="line">&quot;space-after-keywords&quot;: [0, &quot;always&quot;],&#x2F;&#x2F;关键字后面是否要空一格</span><br><span class="line">&quot;space-before-blocks&quot;: [0, &quot;always&quot;],&#x2F;&#x2F;不以新行开始的块&#123;前面要不要有空格</span><br><span class="line">&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],&#x2F;&#x2F;函数定义时括号前面要不要有空格</span><br><span class="line">&quot;space-in-parens&quot;: [0, &quot;never&quot;],&#x2F;&#x2F;小括号里面要不要有空格</span><br><span class="line">&quot;space-infix-ops&quot;: 0,&#x2F;&#x2F;中缀操作符周围要不要有空格</span><br><span class="line">&quot;space-return-throw-case&quot;: 2,&#x2F;&#x2F;return throw case后面要不要加空格</span><br><span class="line">&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],&#x2F;&#x2F;一元运算符的前&#x2F;后要不要加空格</span><br><span class="line">&quot;spaced-comment&quot;: 0,&#x2F;&#x2F;注释风格要不要有空格什么的</span><br><span class="line">&quot;strict&quot;: 2,&#x2F;&#x2F;使用严格模式</span><br><span class="line">&quot;use-isnan&quot;: 2,&#x2F;&#x2F;禁止比较时使用NaN，只能用isNaN()</span><br><span class="line">&quot;valid-jsdoc&quot;: 0,&#x2F;&#x2F;jsdoc规则</span><br><span class="line">&quot;valid-typeof&quot;: 2,&#x2F;&#x2F;必须使用合法的typeof的值</span><br><span class="line">&quot;vars-on-top&quot;: 2,&#x2F;&#x2F;var必须放在作用域顶部</span><br><span class="line">&quot;wrap-iife&quot;: [2, &quot;inside&quot;],&#x2F;&#x2F;立即执行函数表达式的小括号风格</span><br><span class="line">&quot;wrap-regex&quot;: 0,&#x2F;&#x2F;正则表达式字面量用小括号包起来</span><br><span class="line">&quot;yoda&quot;: [2, &quot;never&quot;]&#x2F;&#x2F;禁止尤达条件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>Next 侧边添加新的自定义连接</title>
    <url>/createnewlayout.html</url>
    <content><![CDATA[<p><strong>Next 自己的页面布局并不能满足要求的时候，就要自己自定义布局页面</strong></p>
<hr>
<p>1.新建一个工具栏的侧边栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tools</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2.<code>Next</code> 主题配置<code>_config.yml</code>文件<code>menu</code>选项增加<code>tools</code>的链接和<code>icon</code><br><img src="https://img-blog.csdnimg.cn/20200316123900302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.languages文件夹中增加tools文字显示<br><img src="https://img-blog.csdnimg.cn/20200316124014990.png" alt="在这里插入图片描述"><br>4.显示工具的图标gears。这里的图标全部取之于<a href="https://fontawesome.dashgame.com/">Font-Awesome</a><br><img src="https://img-blog.csdnimg.cn/2020031612442176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.效果<br><img src="https://img-blog.csdnimg.cn/20200316124509617.png" alt="在这里插入图片描述"></p>
<p><strong>千里之行<br>始于足下</strong></p>
]]></content>
      <categories>
        <category>github pages hexo建站</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages+hexo 绑定域名</title>
    <url>/github-artical.html</url>
    <content><![CDATA[<p>上一章说到<a href="https://blog.csdn.net/u012733501/article/details/104815568">github pages+hexo 搭建自己的个人博客</a>  ，尚未关联自己的域名，毕竟<code>github pages</code>的 <code>username.github.io</code> 并不怎么好记和美观</p>
<hr>
<a id="more"></a>
<p>@<a href="文章目录">TOC</a></p>
<h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><p>这里我在<a href="https://www.aliyun.com/">阿里云</a>申请的域名，腾讯云、万维等都可以，你自己选择。<br>1、添加两条记录<br><img src="https://img-blog.csdnimg.cn/20200313153122717.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200313153209840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其实说白了就是说解析带www和不带www的地址。<br>基本上这就ok了。<br><strong>但是切记！一定要实名认证！实名认证！实名认证</strong><br>可以看到这里未实名认证，是无法DNS解析的<br><img src="https://img-blog.csdnimg.cn/20200313153356282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="hexo绑定CNAME"><a href="#hexo绑定CNAME" class="headerlink" title="hexo绑定CNAME"></a>hexo绑定CNAME</h2><p>你的博客<code>source</code>目录建立<code>CNAME</code>文件，不带后缀，里面输入你的域名。比如我这里的域名是<a href="http://www.beginnerdone.top">beginnerdone.top</a>，那么输入<a href="http://www.beginnerdone.top">beginnerdone.top</a>即可<br><img src="https://img-blog.csdnimg.cn/20200313153650937.png" alt="在这里插入图片描述"><br>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<p>完成部署。</p>
<h2 id="github绑定域名"><a href="#github绑定域名" class="headerlink" title="github绑定域名"></a>github绑定域名</h2><p>博客setting项中的，github pages选项添加你的域名并保存<br><img src="https://img-blog.csdnimg.cn/20200313153920844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>直接访问<a href="http://beginnerdone.top/">我的博客</a></p>
<p><strong>千里之行<br>始于足下</strong></p>
]]></content>
      <categories>
        <category>github pages hexo建站</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages+hexo 搭建自己的个人博客</title>
    <url>/githubpages-website.html</url>
    <content><![CDATA[<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>1.输入仓库的名称和说明（非必填），仓库名称格式为<code>username.github.io</code>,<strong>username 一定要和用户名一致，否则会404的</strong></p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200312115314279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.点击 Create repository创建仓库<br><img src="https://img-blog.csdnimg.cn/2020031212021255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="创建站点"><a href="#创建站点" class="headerlink" title="创建站点"></a>创建站点</h2><p>1.点击仓库中的setting<br><img src="https://img-blog.csdnimg.cn/20200312120336150.png" alt="在这里插入图片描述"><br>2.找到GitHub Pages 为站点选一个主题<br><img src="https://img-blog.csdnimg.cn/20200312120514883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p> 安装hexo 之前首先安装<a href="https://git-scm.com/download/">git</a> 以及<a href="https://nodejs.org/en/download/">node.js</a>.<br>使用npm 全局安装hexo </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>执行以下命令，创建hexo所需文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo  init</span><br></pre></td></tr></table></figure>
<p>在初始化的文件夹中下载依赖</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h3 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>注意<code>_config.yml</code>文件，网站的 配置 信息，可以在此配置大部分的参数。具体参考<a href="https://hexo.io/zh-cn/docs/configuration">配置信息</a></p>
<h3 id="修改-config-yml文件并部署到github上"><a href="#修改-config-yml文件并部署到github上" class="headerlink" title="修改_config.yml文件并部署到github上"></a>修改_config.yml文件并部署到github上</h3><h4 id="修改-config-yml中"><a href="#修改-config-yml中" class="headerlink" title="修改_config.yml中"></a>修改_config.yml中</h4><p>原有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: ‘’</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:BeginnerDone/beginnerdone.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: 第一次部署</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>使用何种方式进行部署（有git、Heroku、Netlify等等）</td>
<td>必填一种</td>
</tr>
<tr>
<td>repo</td>
<td>库（Repository）地址</td>
<td>我这里使用的是ssh 验证，因为https地址每次输入账号和密码是很麻烦的一件事！推荐使用ssh，没有ssh key的请先生成添加到github上</td>
</tr>
<tr>
<td>branch</td>
<td>分支名称</td>
<td>gh-pages (GitHub)    coding-pages  (Coding.net  master (others)</td>
</tr>
<tr>
<td>message</td>
<td>提交信息</td>
<td></td>
</tr>
</tbody></table>
<p><strong>以上参数冒号后面的参数一定要加空格！空格！空格！</strong></p>
<h4 id="部署访问站点"><a href="#部署访问站点" class="headerlink" title="部署访问站点"></a>部署访问站点</h4><pre><code>执行</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>访问我的<a href="https://beginnerdone.github.io/">github pages 博客</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200312141308417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI3MzM1MDE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h2 id="更改hexo主题"><a href="#更改hexo主题" class="headerlink" title="更改hexo主题"></a>更改hexo主题</h2><p>这里替换的是<a href="http://theme-next.iissnan.com/getting-started.html">Next</a>主题</p>
<h3 id="安装Next"><a href="#安装Next" class="headerlink" title="安装Next"></a>安装Next</h3><p>只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下，然后修改<code>_config.yml</code>文件中的<code>theme</code>节点为<code>next</code>即可<br><img src="https://img-blog.csdnimg.cn/20200312145236454.png" alt="在这里插入图片描述"><br>当然了，不用自己去拷贝那么麻烦，只需要在当前站点文件夹下<br>使用<code>git</code>命令下载<code>next</code>即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>
<p>查看<code>theme</code>文件夹已经下好了<code>next</code>主题<br><img src="https://img-blog.csdnimg.cn/20200312145515337.png" alt="在这里插入图片描述"></p>
<h4 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h4><p><strong>外观<code>Scheme</code>选择</strong></p>
<p><code>Next</code>提供三种 不同的<code>Scheme</code>外观</p>
<p>1.<code>Muse</code> - 默认 <code>Scheme</code>，这是 NexT 最初的版本，黑白主调，大量留白<br>2.<code>Mist</code> - <code>Muse</code> 的紧凑版本，整洁有序的单栏外观<br>3.<code>Pisces</code> - 双栏 <code>Scheme</code>，小家碧玉似的清新<br>只需要在<code>themes\next</code>中的<code>_config.yml</code>中<code>scheme</code>节点启用即可<br>例如这里启用了<code>Mist</code><br><img src="https://img-blog.csdnimg.cn/20200312162628600.png" alt="在这里插入图片描述"><br><strong>设置语言</strong><br>设置根目录<code>_config.yml</code>中的language 为中文，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<p>后续配置参考<a href="http://theme-next.iissnan.com/getting-started.html#select-scheme">Next</a></p>
<h3 id="再次部署"><a href="#再次部署" class="headerlink" title="再次部署"></a>再次部署</h3><p>这里要特别注意，更换主题后，再次部署的时候要执行下，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020031214571113.png" alt="在这里插入图片描述"><br>然后再执行<code>hexo deploy --generate</code>（简写<code>hexo d -g</code>）生成文件自动部署</p>
<hr>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>1.访问首页和归档的时候总是404<br>    url地址后面总会多出%20编码，通过<a href="https://tool.oschina.net/encode?type=4">在线编码转换</a>查出url地址多出了空格。<br>    解决办法就是<code>themes\next</code>中的<code>_config.yml</code>中<code>menu</code>选项中空格全部去掉，比如<code>/archives/</code>后面的空格就要去掉<br>    <img src="https://img-blog.csdnimg.cn/20200312172925521.png" alt="在这里插入图片描述"></p>
<p>个人博客地址：<a href="https://beginnerdone.github.io/">传送门</a><br>github：<a href="https://github.com/BeginnerDone/beginnerdone.github.io">传送门</a><br><strong>千里之行<br>始于足下</strong></p>
]]></content>
      <categories>
        <category>github pages hexo建站</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
